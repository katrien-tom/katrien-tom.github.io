[{"content":" # 一、Docker安装密码管理器Vaultwarden # 1.1 创建专用网络 1 docker network create middleware # 1.2 准备工作 1 2 3 4 5 cd / mkdir mydata mkdir -p mydata/vaultwarden/data mkdir -p mydata/nginx/conf mkdir -p mydata/nginx/ssl # 1.3 安装vaultwarden 1 2 3 4 5 6 7 8 9 10 11 12 docker run -d \\ --name vaultwarden \\ -e INVITATIONS_ALLOWED=false \\ -e ADMIN_TOKEN=token123456 \\ -e TZ=Asia/Shanghai \\ -p 8001:80 \\ --network middleware \\ -v /mydata/vaultwarden/data:/data/ \\ --log-driver json-file \\ --log-opt max-size=200k \\ --log-opt max-file=10 \\ vaultwarden/server:latest # 1.3.1 关闭新注册 注册完管理员账号后进入/admin，将`Allow new signups`选项设置为false。 # 1.4 安装nginx # 1.4.1 生成自签名证书 生成根证书私钥和根证书 使用指定-subj “/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization”,生成根证书私钥和根证书\n1 openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization\u0026#34; -keyout CA-private.key -out CA-certificate.crt -reqexts v3_req -extensions v3_ca 生成自签名证书私钥 1 openssl genrsa -out private.key 2048 根据自签名证书私钥生成自签名证书申请文件 1 openssl req -new -key private.key -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization/CN=192.168.60.68\u0026#34; -sha256 -out private.csr 定义自签名证书扩展文件(解决Chrome安全告警) ​\t定义自签名证书扩展文件(解决Chrome安全告警)。在默认情况下生成的证书一旦选择信任，在 Edge, Firefox 等浏览器都显示为安全，但是Chrome仍然会标记为不安全并警告拦截，这是因为 Chrome 需要证书支持扩展 Subject Alternative Name, 因此生成时需要特别指定 MyExt 扩展并添加相关参数,将下述内容放到一个文件中,命名为private.ext\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 cat \u0026gt; private.ext \u0026lt;\u0026lt; EOF [ req ] default_bits = 1024 distinguished_name = req_distinguished_name req_extensions = MyExt extensions = MyExt [ req_distinguished_name ] countryName = CN stateOrProvinceName = BeiJing localityName = BeiJing organizationName = MyOrganization [MyExt] authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = IP:192.168.60.68 EOF 生成自签名证书 1 2 ##设置100年的证书有效期 openssl x509 -req -days 36500 -in private.csr -CA CA-certificate.crt -CAkey CA-private.key -CAcreateserial -sha256 -out private.crt -extfile private.ext -extensions MyExt 配置Nginx ​\t将上面生成的private.crt和private.key放在nginx下的ssl目录\n客户端安装根证书 ​\t把该证书CA-certificate.crt安装到受信任的根证书颁发机构下\n# 1.4.2 创建配置文件 打开配置文件 1 vim /mydata/nginx/conf/nginx.conf 输入以下内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } server { listen 443 ssl; # server_name your_domain.com; # 替换为你的域名 ssl_certificate /etc/ssl/certs/certificate.pem; ssl_certificate_key /etc/ssl/certs/private-key.pem; ssl_protocols TLSv1.2 TLSv1.3; location / { proxy_pass http://vaultwarden:80; # Vaultwarden的地址和端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } } # 1.4.3 运行nginx 1 2 3 4 5 6 7 docker run -d --name nginx \\ --network middleware \\ -v /mydata/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \\ -v /mydata/nginx/ssl:/etc/ssl/certs \\ -p 8080:80 \\ -p 8081:443 \\ nginx:latest ","date":"2024-05-08T17:00:00+08:00","image":"https://blog.binggao.xyz/img/docker.jpg","permalink":"https://blog.binggao.xyz/p/docker-vaultwarden/","title":"Docker安装密码管理器Vaultwarden"},{"content":" # Nginx生成自签名证书 # 一、生成根证书私钥和根证书 使用指定-subj “/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization”,生成根证书私钥和根证书\n1 openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization\u0026#34; -keyout CA-private.key -out CA-certificate.crt -reqexts v3_req -extensions v3_ca # 二、生成自签名证书私钥 1 openssl genrsa -out private.key 2048 # 三、根据自签名证书私钥生成自签名证书申请文件 1 openssl req -new -key private.key -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization/CN=192.168.60.68\u0026#34; -sha256 -out private.csr # 四、定义自签名证书扩展文件(解决chrome安全告警) ​\t定义自签名证书扩展文件(解决Chrome安全告警)。在默认情况下生成的证书一旦选择信任，在 Edge, Firefox 等浏览器都显示为安全，但是Chrome仍然会标记为不安全并警告拦截，这是因为 Chrome 需要证书支持扩展 Subject Alternative Name, 因此生成时需要特别指定 MyExt 扩展并添加相关参数,将下述内容放到一个文件中,命名为private.ext\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 cat \u0026gt; private.ext \u0026lt;\u0026lt; EOF [ req ] default_bits = 1024 distinguished_name = req_distinguished_name req_extensions = MyExt extensions = MyExt [ req_distinguished_name ] countryName = CN stateOrProvinceName = BeiJing localityName = BeiJing organizationName = MyOrganization [MyExt] authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = IP:192.168.60.68 EOF # 五、生成自签名证书 1 2 ##设置100年的证书有效期 openssl x509 -req -days 36500 -in private.csr -CA CA-certificate.crt -CAkey CA-private.key -CAcreateserial -sha256 -out private.crt -extfile private.ext -extensions MyExt # 六、配置Nginx 将上面生成的private.crt和private.key放在nginx下的ssl目录\n# 七、客户端安装根证书 把该证书CA-certificate.crt安装到受信任的根证书颁发机构下\n","date":"2024-05-08T17:00:00+08:00","image":"https://blog.binggao.xyz/img/nginx.jpg","permalink":"https://blog.binggao.xyz/p/nginx-openssl-self-signed-certificate/","title":"Nginx生成自签名证书"},{"content":" # React 18 基础 # 一、React项目结构 # 1. 清理文件 # 二、JSX基础 # 1. 识别js表达式 在JSX中可以通过 大括号语法{} 识别 JavaScript中的表达式，比如常见的变量、函数调用、方法调用等等。\n使用引号传递字符串\n使用JavaScript变量\n函数调用和方法调用\n使用JavaScript对象\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const count = 100; function getName(){ return \u0026#39;react\u0026#39;; } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is react App {/* 使用引号传递字符串 */} {\u0026#39;this is mesages\u0026#39;} {/* 识别js变量 */} {count} {/* 函数调用 */} {getName()} {/* 方法调用 */} {new Date().getDate()} {/* 使用js对象 */} \u0026lt;div style={{color:\u0026#39;red\u0026#39;}}\u0026gt;this is div\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 注意：if语句、switch语句、变量声明属于语句，不是表达式，不能出现在{}中\n# 2. JSX中实现列表渲染 语法：在JSX中可以使用原生JS中的map方法遍历渲染列表\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const list= [ {id:1001,name:\u0026#39;Vue\u0026#39;}, {id:1002,name:\u0026#39;React\u0026#39;}, {id:1003,name:\u0026#39;Angular\u0026#39;}, ] function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 渲染列表 */} {/* map 循环哪个结构 return结构 */} {/* 注意事项：加上一个独一无二的key、字符串或者number */} {/* key的作用：React框架内部使用，提升更新性能的 */} \u0026lt;ul\u0026gt; {list.map(item=\u0026gt;\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; # 3. 条件渲染 语法：在React中，可以通过逻辑与运算符\u0026amp;\u0026amp;、三元表达式（?:）实现基础的条件渲染\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const isLogin = true; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 逻辑与 \u0026amp;\u0026amp; */} {isLogin\u0026amp;\u0026amp;\u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt;} {/* 三元运算 */} {isLogin ? \u0026lt;span\u0026gt;jack\u0026lt;/span\u0026gt;:\u0026lt;span\u0026gt;loading\u0026lt;/span\u0026gt;} \u0026lt;/div\u0026gt; ); } export default App; # 4. 复杂条件渲染 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const articleType = 2; // 0 1 3 //定义核心函数（根据文章类型返回不同的JSX模板 function getArticleTem() { if (articleType === 0) { return \u0026lt;div\u0026gt;我是无图模式\u0026lt;/div\u0026gt;; } else if (articleType === 1) { return \u0026lt;div\u0026gt;我是单图模式\u0026lt;/div\u0026gt;; } else { return \u0026lt;div\u0026gt;我是三图模式\u0026lt;/div\u0026gt;; } } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 调用函数渲染不同的模板 */} {getArticleTem()} \u0026lt;/div\u0026gt; ); } export default App; # 5. React中的事件绑定 语法：on + 事件名称 = { 事件处理程序 }，整体上遵循驼峰命名法\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function App() { const clickHandler1 = (e)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,e); } const clickHandler2 = (param)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,param); } const clickHandler3 = (param,e)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,param,e); } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={clickHandler1}\u0026gt;click me1\u0026lt;/button\u0026gt; \u0026lt;button onClick={()=\u0026gt;clickHandler2(\u0026#39;jack\u0026#39;)}\u0026gt;click me2\u0026lt;/button\u0026gt; \u0026lt;button onClick={(e)=\u0026gt;clickHandler3(\u0026#39;jack\u0026#39;,e)}\u0026gt;click me3\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 6. React中的组件 概念：一个组件就是用户界面的一部分，它可以有自己的逻辑和外观，组件之间可以互相嵌套，也可以复用多次\n组件化开发可以让开发者像搭积木一样构建一个完整的庞大的应用。\n# 6.1 React组件 在React中，一个组件就是首字母大写的函数，内部存放了组件的逻辑和视图UI, 渲染组件只需要把组件当成标签书写即可。\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Button(){ // 业务逻辑组件逻辑 return \u0026lt;button\u0026gt;click me!\u0026lt;/button\u0026gt; } function App() { return ( \u0026lt;\u0026gt; {/* 自闭和 */} \u0026lt;Button/\u0026gt; {/* 成对标签 */} \u0026lt;Button\u0026gt;\u0026lt;/Button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 7. useState useState 是一个 React Hook（函数），它允许我们向组件添加一个状态变量, 从而控制影响组件的渲染结果。\n# 7.1 useState基础使用 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { useState } from \u0026#34;react\u0026#34;; function App() { // 1. 调用useState 添加一个状态变量 // count 状态变量 // setCount 修改状态变量的方法 const [count,setCount] = useState(0) // 2. 点击事件回调 const clickHandlerCallback=()=\u0026gt;{ // 作用1. 用传入的新值需改count // 2.重新使用新的count渲染ui setCount(count+1) } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={clickHandlerCallback}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 7.2 修改状态的规则 在React中，状态被认为是只读的，我们应该始终替换它而不是修改它，直接修改状态不能引发视图更新\n# 8. 组件的样式处理 React组件基础的样式控制有俩种方式：\n行内样式（不推荐）\nclass类名控制\napp.css\n1 2 3 4 .foo{ color: red; font-size: 20px; } App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 导入样式 import \u0026#39;./app.css\u0026#39; const style = { color:\u0026#39;red\u0026#39;, fontSize:\u0026#39;50px\u0026#39; } function App() { return ( \u0026lt;\u0026gt; {/* 行内样式控制 */} \u0026lt;span style={style}\u0026gt;this is line style\u0026lt;/span\u0026gt; {/* 通过class类名控制 */} \u0026lt;span className=\u0026#34;foo\u0026#34;\u0026gt;this is class control style\u0026lt;/span\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 9. 受控表单绑定 概念：使用React组件的状态（useState）控制表单的状态\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { useState } from \u0026#34;react\u0026#34;; // 1. 声明一个react状态 - useState // 2. 核心绑定流程 // 2.1 通过value属性绑定react状态 // 2.2 绑定onChange事件，通过事件参数e拿到输入框最新的值，反向修改到react状态 function App() { const [value,setValue] = useState(\u0026#39;\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;input value={value} onChange={(e)=\u0026gt;setValue(e.target.value)}\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 10. React中获取DOM 在 React 组件中获取/操作 DOM，需要使用 useRef React Hook钩子函数，分为两步：\n使用useRef创建 ref 对象，并与 JSX 绑定\n在DOM可用时，通过 inputRef.current 拿到 DOM 对象\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {useRef} from \u0026#34;react\u0026#34; // 1. useRef 生成ref对象，绑定到dom标签上 // 2. dom可用时，ref.current获取dom // 渲染完毕之后dom生成之后才可用 function App() { const inputRef = useRef(null) return ( \u0026lt;\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={()=\u0026gt;console.dir(inputRef.current)}\u0026gt;获取dom\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11. 组件通信 概念：组件通信就是组件之间的数据传递，根据组件嵌套关系的不同，有不同的通信方法\n# 11.1 父传子 # 11.1.1 基础实现 实现步骤：\n父组件传递数据 - 在子组件标签上绑定属性\n子组件接收数据 - 子组件通过props参数接收数据\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 1. 父组件传递数据 - 在子组件标签上绑定属性 // 2. 子组件接收数据 - 子组件通过props参数接收数据 function Son(props){ // props：对象里面包含了父组件传递过来的所有的数据 console.log(props); return \u0026lt;div\u0026gt;this is son,{props.name}\u0026lt;/div\u0026gt; } function App() { const name = \u0026#39;this is app name\u0026#39; return ( \u0026lt;\u0026gt; \u0026lt;Son name={name}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.1.2 父传子-props说明 props可传递任意的数据\n​\t数字、字符串、布尔值、数组、对象、函数、JSX\nprops是只读对象\n​\t子组件只能读取props中的数据，不能直接进行修改, 父组件的数据只能由父组件修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function Son(props){ console.log(props); return \u0026lt;div\u0026gt;this is son,{props.name},jsx:{props.child}\u0026lt;/div\u0026gt; } function App() { const name = \u0026#39;this is app name\u0026#39; return ( \u0026lt;\u0026gt; \u0026lt;Son name={name} age={18} isTrue={false} list={[\u0026#39;vue\u0026#39;,\u0026#39;react\u0026#39;]} obj={{name:\u0026#39;jack\u0026#39;}} cb={()=\u0026gt;console.log(123)} child={\u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.1.3 父传子-children说明 场景：当我们把内容嵌套在子组件标签中时，父组件会自动在名为children的prop属性中接收该内容\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function Son(props){ console.log(props); return \u0026lt;div\u0026gt;this is son,{props.children}\u0026lt;/div\u0026gt; } function App() { return ( \u0026lt;\u0026gt; \u0026lt;Son\u0026gt; \u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt; \u0026lt;/Son\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.2 子传父 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function Son({onGetMsg}){ const sonMsg = \u0026#39;this is son msg\u0026#39; return \u0026lt;div\u0026gt;this is son \u0026lt;button onClick={()=\u0026gt;onGetMsg(sonMsg)}\u0026gt;senMsg\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } function App() { const getMsg = (msg)=\u0026gt;{ console.log(msg); } return ( \u0026lt;\u0026gt; \u0026lt;Son onGetMsg={getMsg}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.3 使用状态提升实现兄弟组件通信 实现思路：借助“状态提升”机制，通过父组件进行兄弟组件之间的数据传递\nA组件先通过子传父的方式把数据传给父组件App\nApp拿到数据后通过父传子的方式再传递给B组件\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import { useState } from \u0026#34;react\u0026#34; // 1. 通过子传父 A-\u0026gt;App // 2. 通过父传子 App-\u0026gt;B function A({onGetAData}){ // A 组件中数据 const name = \u0026#39;this is A name\u0026#39; return ( \u0026lt;div\u0026gt; this is A component \u0026lt;button onClick={()=\u0026gt;onGetAData(name)}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } function B(props){ // A 组件中数据 return ( \u0026lt;div\u0026gt; this is B component,{props.aMsg} \u0026lt;/div\u0026gt; ) } function App() { const [aMsg,setAMsg] = useState(\u0026#39;\u0026#39;) const getAData=(aData)=\u0026gt;{ console.log(aData); setAMsg(aData) } return ( \u0026lt;\u0026gt; this is App \u0026lt;A onGetAData={getAData}/\u0026gt; \u0026lt;B aMsg={aMsg}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.4 使用Context机制跨层级组件通信 实现步骤：\n使用createContext方法创建一个上下文对象Ctx\n在顶层组件（App）中通过 Ctx.Provider 组件提供数据\n在底层组件（B）中通过 useContext 钩子函数获取消费数据\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // App-\u0026gt;A-\u0026gt;B import { useContext } from \u0026#34;react\u0026#34;; import { createContext } from \u0026#34;react\u0026#34;; // 1. createContext方法创建一个上下文对象 const MsgContext = createContext() function A(){ return ( \u0026lt;div\u0026gt; this is A component \u0026lt;B/\u0026gt; \u0026lt;/div\u0026gt; ) } // 3. 在底层组件，通过useContext钩子函数使用数据 function B(){ const msg = useContext(MsgContext) return ( \u0026lt;div\u0026gt; this is B component,{msg} \u0026lt;/div\u0026gt; ) } function App() { const msg = \u0026#39;this is app msg\u0026#39; return ( \u0026lt;\u0026gt; {/* 2. 在顶层组件，通过Provider组件提供数据 */} \u0026lt;MsgContext.Provider value={msg}\u0026gt; this is App \u0026lt;A/\u0026gt; \u0026lt;/MsgContext.Provider\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12. useEffect的使用 ​\tuseEffect是一个React Hook函数，用于在React组件中创建不是由事件引起而是由渲染本身引起的操作（副作用）, 比\n如发送AJAX请求，更改DOM等等。\n说明：上面的组件中没有发生任何的用户事件，组件渲染完毕之后就需要和服务器要数据，整个过程属于“只由渲染引起的操作”\n# 12.1 useEffect 的基础使用 需求：在组件渲染完毕之后，立刻从服务端获取频道列表数据并显示到页面中\n语法：\n1 useEffect(()=\u0026gt;{},[]) 参数1是一个函数，可以把它叫做副作用函数，在函数内部可以放置要执行的操作\n参数2是一个数组（可选参），在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，`当是一个空数组的时候，副作用函数\n只会在组件渲染完毕之后执行一次。`\n接口地址：http://geek.itheima.net/v1_0/channels\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; const URL = \u0026#34;http://geek.itheima.net/v1_0/channels\u0026#34; function App() { // 创建一个状态数据 const [list,setList] = useState([]) useEffect(()=\u0026gt;{ // 额外的操作，获取频道列表 async function getList(){ const res = await fetch(URL) const jsonResp = await res.json() setList(jsonResp.data.channels) } getList() },[]) return ( \u0026lt;\u0026gt; this is app \u0026lt;ul\u0026gt; {list.map(item=\u0026gt;\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2 useEffect 依赖项参数说明 useEffect副作用函数的执行时机存在多种情况，根据传入依赖项的不同，会有不同的执行表现。\n依赖项 副作用函数执行时机 没有依赖项 组件初始渲染 + 组件更新时执行 空数组依赖项 只在初始渲染时执行一次 添加特定依赖项 组件初始渲染 + 特性依赖项变化时执行 # 12.2.1 没有依赖项 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 1. 没有依赖项 组件初始渲染 + 组件更新时执行 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); }) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2.2 空数组依赖项 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 2. 空数组依赖项 只在初始渲染时执行一次 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); },[]) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2.3 特定依赖项 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 3. 添加特定依赖项 组件初始渲染 + 特性依赖项变化时执行 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); },[count]) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.3 useEffect — 清除副作用 在useEffect中编写的由渲染本身引起的对接组件外部的操作，社区也经常把它叫做副作用操作，比如在useEffect中开\n启了一个定时器，我们想在组件卸载时把这个定时器再清理掉，这个过程就是清理副作用。\n1 2 3 4 5 6 useEffect(()=\u0026gt;{ // 实现副作用操作逻辑 return ()=\u0026gt;{ //清除副作用逻辑 } },[]) 说明：清除副作用的函数最常见的执行时机是在组件卸载时自动执行\n需求：在Son组件渲染时开启一个定制器，卸载时清除这个定时器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function Son(){ // 1. 渲染时开启一个定时器 useEffect(()=\u0026gt;{ const timer = setInterval(()=\u0026gt;{ console.log(\u0026#34;定时器执行中\u0026#34;); },1000) return ()=\u0026gt;{ // 清除副作用（组件卸载时） clearInterval(timer) } },[]) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; } function App() { // 通过条件渲染模拟组件卸载 const [show,setShow] = useState(true) return ( \u0026lt;\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Son/\u0026gt;} \u0026lt;button onClick={()=\u0026gt;setShow(false)}\u0026gt;卸载Son组件\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 13. 自定义Hook函数 概念：自定义Hook是以 use 打头的函数，通过自定义Hook函数可以用来实现逻辑的封装和复用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { useState } from \u0026#34;react\u0026#34;; function useToggle(){ const [value,setValue] = useState(false) const toggle=()=\u0026gt;setValue(!value) return { value, toggle } } // 封装自定义hook通用思路 // 1. 声明一个以use打头的函数； // 2. 在函数体内封装可复用的逻辑（只要是可复用的逻辑）； // 3. 把组件中用到的状态或者回调return出去（以对象或者数组）； // 4. 在哪个组件中要用到这个逻辑，就执行这个函数，解构出来状态和回调进行使用。 function App() { const {value,toggle} = useToggle() return ( \u0026lt;\u0026gt; {value \u0026amp;\u0026amp; \u0026lt;div\u0026gt;this is dive\u0026lt;/div\u0026gt;} \u0026lt;button onClick={toggle}\u0026gt;toggle\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 14. React Hooks使用规则 使用规则\n只能在组件中或者其他自定义Hook函数中调用 只能在组件的顶层调用，不能嵌套在 if、for、其他函数中 # 三、Redux # 1. Redux介绍 Redux 是React最常用的集中状态管理工具，类似于Vue中的Pinia（Vuex），可以独立于框架运行 作用：通过集中管理的方式管理应用的状态\n为什么要使用Redux？\n独立于组件，无视组件之间的层级关系，简化通信问题 单项数据流清晰，易于定位bug 调试工具配套良好，方便调试 # 2. Redux快速体验 # 2.1 实现计数器 需求：不和任何框架绑定，不使用任何构建工具，使用纯Redux实现计数器\n使用步骤：\n定义一个 reducer 函数 （根据当前想要做的修改返回一个新的状态） 使用createStore方法传入 reducer函数 生成一个store实例对象 使用store实例的 subscribe方法 订阅数据的变化（数据一旦变化，可以得到通知） 使用store实例的 dispatch方法提交action对象 触发数据变化（告诉reducer你想怎么改数据） 使用store实例的 getState方法 获取最新的状态数据更新到视图中 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;button id=\u0026#34;decrement\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/redux@latest/dist/redux.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 定义reducer函数 // 作用: 根据不同的action对象，返回不同的新的state // state: 管理的数据初始状态 // action: 对象 type 标记当前想要做什么样的修改 function reducer (state = { count: 0 }, action) { // 数据不可变：基于原始状态生成一个新的状态 if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { count: state.count + 1 } } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { count: state.count - 1 } } return state } // 2. 使用reducer函数生成store实例 const store = Redux.createStore(reducer) // 3. 通过store实例的subscribe订阅数据变化 // 回调函数可以在每次state发生变化的时候自动执行 store.subscribe(() =\u0026gt; { console.log(\u0026#39;state变化了\u0026#39;, store.getState()) document.getElementById(\u0026#39;count\u0026#39;).innerText = store.getState().count }) // 4. 通过store实例的dispatch函数提交action更改状态 const inBtn = document.getElementById(\u0026#39;increment\u0026#39;) inBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 增 store.dispatch({ type: \u0026#39;INCREMENT\u0026#39; }) }) const dBtn = document.getElementById(\u0026#39;decrement\u0026#39;) dBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 减 store.dispatch({ type: \u0026#39;DECREMENT\u0026#39; }) }) // 5. 通过store实例的getState方法获取最新状态更新到视图中 \u0026lt;/script\u0026gt; # 3. Redux数据流架构 Redux的难点是理解它对于数据修改的规则, 下图动态展示了在整个数据的修改中，数据的流向\n为了职责清晰，Redux代码被分为三个核心的概念，我们学redux，其实就是学这三个核心概念之间的配合，三个概念分别是:\nstate: 一个对象 存放着我们管理的数据 action: 一个对象 用来描述你想怎么改数据 reducer: 一个函数 根据action的描述更新state # 4. Redux与React - 环境准备 Redux虽然是一个框架无关可以独立运行的插件，但是社区通常还是把它与React绑定在一起使用，以一个计数器案例体验一下Redux + React 的基础使用\n# 4.1 配套工具 在React中使用redux，官方要求安装俩个其他插件 - Redux Toolkit 和 react-redux\nRedux Toolkit（RTK）- 官方推荐编写Redux逻辑的方式，是一套工具的集合集，简化书写方式\nreact-redux - 用来 链接 Redux 和 React组件 的中间件\n# 4.2 配置基础环境 使用 CRA 快速创建 React 项目 1 npx create-react-app react-redux 安装配套工具 1 npm i @reduxjs/toolkit react-redux 启动项目 1 npm run start # 4.3 store目录结构设计 通常集中状态管理的部分都会单独创建一个单独的 store 目录\n应用通常会有很多个子store模块，所以创建一个 modules 目录，在内部编写业务分类的子store\nstore中的入口文件 index.js 的作用是组合modules中所有的子模块，并导出store\n# 5. Redux与React - 实现counter # 5.1 整体路径熟悉 # 5.2 使用React Toolkit 创建 counterStore modules/counterStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; const counterStore = createSlice({ // 模块名称独一无二 name: \u0026#39;counter\u0026#39;, // 初始数据 initialState: { count: 1 }, // 修改数据的同步方法,支持直接修改 reducers: { increment (state) { state.count++ }, decrement(state){ state.count-- } } }) // 解构出actionCreater const { increment,decrement } = counterStore.actions // 获取reducer函数 const counterReducer = counterStore.reducer // 按需导出的方式导出actionCreater export { increment, decrement } // 以默认导出的方式导出reducer export default counterReducer store/index.js\n1 2 3 4 5 6 7 8 9 10 11 import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39; // 导入子模块reducer import counterReducer from \u0026#39;./modules/counterStore\u0026#39; const store = configureStore({ reducer: { // 注册子模块 counter: counterReducer } }) export default store # 5.3 为React注入store react-redux负责把Redux和React 链接 起来，内置 Provider组件 通过 store 参数把创建好的store实例注入到应用中，链接正式建立\nindex.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; import App from \u0026#39;./App\u0026#39; // 导入store import store from \u0026#39;./store\u0026#39; // 导入store提供组件Provider import { Provider } from \u0026#39;react-redux\u0026#39; ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render( // 提供store数据 \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; ) # 5.4 React组件使用store中的数据 在React组件中使用store中的数据，需要用到一个钩子函数 - useSelector，它的作用是把store中的数据映射到组件中，使用样例如下：\n# 5.5 React组件修改store中的数据 React组件中修改store中的数据需要借助另外一个hook函数 - useDispatch，它的作用是生成提交action对象的dispatch函数，使用样例如下：\n# 6. Redux与React - 提交action传参 需求：组件中有俩个按钮 add to 10 和 add to 20 可以直接把count值修改到对应的数字，目标count值是在组件中传递过去的，需要在提交action的时候传递参数\n实现方式：在reducers的同步修改方法中添加action对象参数，在调用actionCreater的时候传递参数，参数会被传递到action对象payload属性上\n# 7. Redux与React - 异步action处理 需求理解 实现步骤\n创建store的写法保持不变，配置好同步修改状态的方法 单独封装一个函数，在函数内部return一个新函数，在新函数中 2.1 封装异步请求获取数据 2.2 调用同步actionCreater传入异步数据生成一个action对象，并使用dispatch提交 组件中dispatch的写法保持不变 代码实现\n测试接口地址： http://geek.itheima.net/v1_0/channels\nchannelStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import axios from \u0026#39;axios\u0026#39; const channelStore = createSlice({ name: \u0026#39;channel\u0026#39;, initialState: { channelList: [] }, reducers: { setChannelList (state, action) { state.channelList = action.payload } } }) // 创建异步 const { setChannelList } = channelStore.actions const url = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; // 封装一个函数 在函数中return一个新函数 在新函数中封装异步 // 得到数据之后通过dispatch函数 触发修改 const fetchChannelList = () =\u0026gt; { return async (dispatch) =\u0026gt; { const res = await axios.get(url) dispatch(setChannelList(res.data.data.channels)) } } export { fetchChannelList } const channelReducer = channelStore.reducer export default channelReducer store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39; // 导入子模块reducer import counterReducer from \u0026#39;./modules/counterStore\u0026#39; import channelReducer from \u0026#39;./modules/channelStore\u0026#39; const store = configureStore({ reducer: { // 注册子模块 counter: counterReducer, channel: channelReducer } }) export default store App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { useEffect } from \u0026#39;react\u0026#39; import { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39; import { fetchChannelList } from \u0026#39;./store/channelStore\u0026#39; function App () { // 使用数据 const { channelList } = useSelector(state =\u0026gt; state.channel) useEffect(() =\u0026gt; { dispatch(fetchChannelList()) }, [dispatch]) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {channelList.map(task =\u0026gt; \u0026lt;li key={task.id}\u0026gt;{task.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 8. Redux调试 - devtools Redux官方提供了针对于Redux的调试工具，支持实时state信息展示，action提交信息查看等\n# 四、ReactRouter # 4.1 ReactRouter快速体验 # 4.1.1 什么是前端路由 一个路径 path 对应一个组件 component 当我们在浏览器中访问一个 path 的时候，path 对应的组件会在页面中进行渲染 # 4.1.2 创建路由开发环境 1 2 3 4 5 6 7 8 # 使用CRA创建项目 npm create-react-app react-router-pro # 安装最新的ReactRouter包 npm i react-router-dom # 启动项目 npm run start # 4.1.3 快速开始 index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; // 1.创建router实例对象并且配置路由对应关系 const router = createBrowserRouter([ { path:\u0026#39;/login\u0026#39;, element: \u0026lt;div\u0026gt;登录\u0026lt;/div\u0026gt; }, { path:\u0026#39;/article\u0026#39;, element: \u0026lt;div\u0026gt;文章\u0026lt;/div\u0026gt; } ]) ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render( {/* 2.路由绑定 */} \u0026lt;RouterProvider router={router}/\u0026gt; ) # 4.1.4 抽象路由模块 pages/Article/index.js\n1 2 3 4 5 6 7 const Article = ()=\u0026gt;{ return \u0026lt;div\u0026gt;我是文章页\u0026lt;/div\u0026gt; } export default Article pages/Login/index.js\n1 2 3 4 5 6 7 const Login = ()=\u0026gt;{ return \u0026lt;div\u0026gt;我是登录页\u0026lt;/div\u0026gt; } export default Login router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import Login from \u0026#34;../pages/Login\u0026#34;; import Article from \u0026#34;../pages/Article\u0026#34;; import { createBrowserRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createBrowserRouter([ { path:\u0026#39;/login\u0026#39;, element:\u0026lt;Login/\u0026gt; }, { path:\u0026#39;/article\u0026#39;, element:\u0026lt;Article/\u0026gt; } ]); export default router index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; import \u0026#39;./index.css\u0026#39;; import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; import { RouterProvider } from \u0026#39;react-router-dom\u0026#39;; import router from \u0026#39;./router\u0026#39;; const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;RouterProvider router={router}\u0026gt;\u0026lt;/RouterProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); # 4.2 路由导航 # 4.2.1 什么是路由导航 路由系统中的多个路由之间需要进行路由跳转，并且在跳转的同时有可能需要传递参数进行通信 # 4.2.2 声明式导航 声明式导航是指通过在模版中通过 \u0026lt;Link/\u0026gt; 组件描述出要跳转到哪里去，比如后台管理系统的左侧菜单通常使用这种方式进行\n语法说明：通过给组件的to属性指定要跳转到路由path，组件会被渲染为浏览器支持的a链接，如果需要传参直接通过字符串拼接的方式拼接参数即可\n# 4.2.3 编程式导航 编程式导航是指通过 useNavigate 钩子得到导航方法，然后通过调用方法以命令式的形式进行路由跳转，比如想在登录请求完毕之后跳转就可以选择这种方式，更加灵活\n语法说明：通过调用navigate方法传入地址path实现跳转\n# 4.2. 导航传参 注：params传参要在router/index.js文件path属性里面添加/article/:id/:name。\n# 4.3 嵌套路由配置 # 4.3.1 什么是嵌套路由 在一级路由中又内嵌了其他路由，这种关系就叫做嵌套路由，嵌套至一级路由内的路由又称作二级路由，例如： # 4.3.2 嵌套路由配置 实现步骤\n1. 使用 `children`属性配置路由嵌套关系 2. 使用 `\u0026lt;Outlet/\u0026gt;` 组件配置二级路由渲染位置 # 4.3.3 默认二级路由 当访问的是一级路由时，默认的二级路由组件可以得到渲染，只需要在二级路由的位置去掉path，设置index属性为true\n注：设置默认路由后，获取参数/?id=100，子组件和父组件都可以接受到参数值\n# 4.3.4 404路由配置 场景：当浏览器输入url的路径在整个路由配置中都找不到对应的 path，为了用户体验，可以使用 404 兜底组件进行渲染\n实现步骤：\n准备一个NotFound组件 在路由表数组的末尾，以*号作为路由path配置路由 # 4.3.5 俩种路由模式 各个主流框架的路由常用的路由模式有俩种，history模式和hash模式, ReactRouter分别由 createBrowerRouter 和 createHashRouter 函数负责创建\n路由模式 url表现 底层原理 是否需要后端支持(nginx转发) history url/login history对象 + pushState事件 需要 hash url/#/login 监听hashChange事件 不需要 # 五、常用Hook函数 # 5.1 useReducer 作用：和useState的作用类似，用来管理相对复杂的状态数据\n# 5.1.1 基础用法 定义一个reducer函数（根据不同的action返回不同的新状态） 在组件中调用useReducer，并传入reducer函数和状态的初始值 事件发生时，通过dispatch函数分派一个action对象（通知reducer要返回哪个新状态并渲染UI） App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { useReducer } from \u0026#39;react\u0026#39; // 1. 定义reducer函数，根据不同的action返回不同的新状态 function reducer(state, action) { switch (action.type) { case \u0026#39;INC\u0026#39;: return state + 1 case \u0026#39;DEC\u0026#39;: return state - 1 default: return state } } function App() { // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( \u0026lt;\u0026gt; {/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DEC\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; {state} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;INC\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.1.2 修改state值-分派action传参 做法：分派action时如果想要传递参数，需要在action对象中添加一个payload参数，放置状态参数\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 定义reducer import { useReducer } from \u0026#39;react\u0026#39; // 1. 根据不同的action返回不同的新状态 function reducer(state, action) { console.log(\u0026#39;reducer执行了\u0026#39;) switch (action.type) { case \u0026#39;INC\u0026#39;: return state + 1 case \u0026#39;DEC\u0026#39;: return state - 1 case \u0026#39;UPDATE\u0026#39;: return state + action.payload default: return state } } function App() { // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( \u0026lt;\u0026gt; {/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DEC\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; {state} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;INC\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;UPDATE\u0026#39;, payload: 100 })}\u0026gt; update to 100 \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.1.3 更新流程 # 5.2 useMemo 作用：它在每次重新渲染的时候能够缓存计算的结果\n# 5.2.1 示例 下面我们的本来的用意是想基于count的变化计算斐波那契数列之和，但是当我们修改num状态的时候，斐波那契求和函数也会被执行，显然是一种浪费\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // useMemo // 作用：在组件渲染时缓存计算的结果 import { useState } from \u0026#39;react\u0026#39; function factorialOf(n) { console.log(\u0026#39;斐波那契函数执行了\u0026#39;) return n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1) } function App() { const [count, setCount] = useState(0) // 计算斐波那契之和 const sumByCount = factorialOf(count) const [num, setNum] = useState(0) return ( \u0026lt;\u0026gt; {sum} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+count:{count}\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNum(num + 1)}\u0026gt;+num:{num}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App 优化：useMemo缓存计算结果，只有count发生变化时才重新进行计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { useMemo, useState } from \u0026#39;react\u0026#39; function fib (n) { console.log(\u0026#39;计算函数执行了\u0026#39;) if (n \u0026lt; 3) return 1 return fib(n - 2) + fib(n - 1) } function App() { const [count, setCount] = useState(0) // 计算斐波那契之和 // const sum = fib(count) // 通过useMemo缓存计算结果，只有count发生变化时才重新计算 const sum = useMemo(() =\u0026gt; { return fib(count) }, [count]) const [num, setNum] = useState(0) return ( \u0026lt;\u0026gt; {sum} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+count:{count}\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNum(num + 1)}\u0026gt;+num:{num}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3 React.memo 作用：允许组件在props没有改变的情况下跳过重新渲染\n# 5.3.1 组件默认的渲染机制 默认机制：顶层组件发生重新渲染，这个组件树的子级组件都会被重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // memo // 作用：允许组件在props没有改变的情况下跳过重新渲染 import { useState } from \u0026#39;react\u0026#39; function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; } function App() { const [, forceUpdate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpdate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3.2 使用React.memo优化 机制：只有props发生变化时才重新渲染 下面的子组件通过 memo 进行包裹之后，返回一个新的组件MemoSon, 只有传给MemoSon的props参数发生变化时才会重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React, { useState } from \u0026#39;react\u0026#39; const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }) function App() { const [, forceUpdate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpdate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App props变化重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import React, { useState } from \u0026#39;react\u0026#39; const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }) function App() { console.log(\u0026#39;父组件重新渲染了\u0026#39;) const [count, setCount] = useState(0) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon count={count} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3.3 props的比较机制 对于props的比较，进行的是‘浅比较’，底层使用 Object.is 进行比较，针对于对象数据类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心对象中的具体属性\n示例：\nprop是简单类型\nObject.is(3,3)=\u0026gt;true 没有变化\nprop是引用类型（对象/数组）\nObject.is([],[])=\u0026gt;false 有变化，React只关心引用是否变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // React.memo props比较机制 // 1. 传递一个简单类型的prop prop变化时组件重新渲染 // 2. 传递一个引用类型的prop 比较的是新值和旧值的引用是否相等 当父组件的函数重新执行时，实际上形成的是新的数组引用 // 3. 保证引用稳定 -》 useMemo 组件渲染过程中缓存一个值 import { useMemo } from \u0026#34;react\u0026#34;; import { useState } from \u0026#34;react\u0026#34;; import { memo } from \u0026#34;react\u0026#34;; const MemoSon= memo(function Son({list}){ console.log(\u0026#39;子组件重新渲染\u0026#39;); return \u0026lt;div\u0026gt;this is Son{list}\u0026lt;/div\u0026gt; }) function App() { const [count,setCount] = useState(0) const list = useMemo(()=\u0026gt;{ return [1,2,3] },[]) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;MemoSon list={list}/\u0026gt; \u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;change count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; # 5.3.4 自定义比较函数 如果上一小节的例子，我们不想通过引用来比较，而是完全比较数组的成员是否完全一致，则可以通过自定义比较函数来实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import React, { useState } from \u0026#39;react\u0026#39; // 自定义比较函数 function arePropsEqual(oldProps, newProps) { console.log(oldProps, newProps) return ( oldProps.list.length === newProps.list.length \u0026amp;\u0026amp; oldProps.list.every((oldItem, index) =\u0026gt; { const newItem = newProps.list[index] console.log(newItem, oldItem) return oldItem === newItem }) ) } const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }, arePropsEqual) function App() { console.log(\u0026#39;父组件重新渲染了\u0026#39;) const [list, setList] = useState([1, 2, 3]) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon list={list} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; setList([1, 2, 3])}\u0026gt; 内容一样{JSON.stringify(list)} \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setList([4, 5, 6])}\u0026gt; 内容不一样{JSON.stringify(list)} \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.4 useCallback 作用：在组件多次重新渲染的时候缓存函数\nuseCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // useCallBack import { memo, useCallback, useState } from \u0026#39;react\u0026#39; const MemoSon = memo(function Son() { console.log(\u0026#39;Son组件渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; }) function App() { const [, forceUpate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) const onGetSonMessage = useCallback((message) =\u0026gt; { console.log(message) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;MemoSon onGetSonMessage={onGetSonMessage} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 5.5 forwardRef 作用：允许组件使用ref将一个DOM节点暴露给父组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { forwardRef, useRef } from \u0026#39;react\u0026#39; const MyInput = forwardRef(function Input(props, ref) { return \u0026lt;input {...props} type=\u0026#34;text\u0026#34; ref={ref} /\u0026gt; }, []) function App() { const ref = useRef(null) const focusHandle = () =\u0026gt; { console.log(ref.current.focus()) } return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={ref} /\u0026gt; \u0026lt;button onClick={focusHandle}\u0026gt;focus\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 5.6 useImperativeHandle 作用：通过ref暴露子组件中的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { forwardRef, useImperativeHandle, useRef } from \u0026#39;react\u0026#39; const MyInput = forwardRef(function Input(props, ref) { // 实现内部的聚焦逻辑 const inputRef = useRef(null) const focus = () =\u0026gt; inputRef.current.focus() // 暴露子组件内部的聚焦方法 useImperativeHandle(ref, () =\u0026gt; { return { focus, } }) return \u0026lt;input {...props} ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; }) function App() { const ref = useRef(null) const focusHandle = () =\u0026gt; ref.current.focus() return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={ref} /\u0026gt; \u0026lt;button onClick={focusHandle}\u0026gt;focus\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 六、 zustand状态管理 # 6.1 快速上手 store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { create } from \u0026#39;zustand\u0026#39; // 1. 创建store // 语法容易出错 // 1. 函数参数必须返回一个对象，对象内部编写状态数据和方法 // 2. set是用来修改数据的专门方法必须调用它来修改数据 // 语法1：参数是函数 需要在原数据基础上修改 set(state =\u0026gt; ({ count: state.count + 1 })) // 语法2：参数直接是一个对象 替换原数据 set({count:100}) const useStore = create((set) =\u0026gt; { return { count: 0, inc: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } }) export default useStore App.js\n1 2 3 4 5 6 7 8 import useStore from \u0026#39;./store/useCounterStore.js\u0026#39; function App() { const { count, inc } = useStore() return \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; } export default App # 6.2 异步支持 对于异步操作的支持不需要特殊的操作，直接在函数中编写异步逻辑，最后把接口的数据放到set函数中返回即可\nstore/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { create } from \u0026#39;zustand\u0026#39; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; const useStore = create((set) =\u0026gt; { return { count: 0, ins: () =\u0026gt; { return set(state =\u0026gt; ({ count: state.count + 1 })) }, channelList: [], fetchChannelList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({channelList: jsonData.data.channels}) } } }) export default useStore App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { useEffect } from \u0026#39;react\u0026#39; import useChannelStore from \u0026#39;./store/channelStore\u0026#39; function App() { const { channelList, fetchChannelList } = useChannelStore() useEffect(() =\u0026gt; { fetchChannelList() }, [fetchChannelList]) return ( \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ) } export default App # 6.3 切片模式 场景：当我们单个store比较大的时候，可以采用一种切片模式进行模块拆分再组合\nstore/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { create } from \u0026#39;zustand\u0026#39; // 创建counter相关切片 const createCounterStore = (set) =\u0026gt; { return { count: 0, setCount: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } } // 创建channel相关切片 const createChannelStore = (set) =\u0026gt; { return { channelList: [], fetchGetList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({ channelList: jsonData.data.channels }) } } } // 组合切片 const useStore = create((...a) =\u0026gt; ({ ...createCounterStore(...a), ...createChannelStore(...a) })) App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function App() { const {count, inc, channelList, fetchChannelList } = useStore() return ( \u0026lt;\u0026gt; \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 九、工具类 # 1. lodash 排序工具 # 2. classnames 优化类名控制 # 3. dayjs ","date":"2024-05-08T17:00:00+08:00","image":"https://blog.binggao.xyz/p/react-basic/assets/1_hu98f6fd50a4f2e293a2be77495df51183_325303_120x120_fill_box_smart1_3.png","permalink":"https://blog.binggao.xyz/p/react-basic/","title":"React18 基础"},{"content":" # RPC和GRPC基础知识 # 一、基础 # 1.1 概念 RPC（Remote Procedure Call） 远程过程调用。 RPC是一种通过网络从远程计算机程序上请求服务，不需要了解底层网络技术的协议。 RPC主要作用就是不同的服务间方法调用就像本地调用一样便捷。 本地调用转变为远程过程调用带来的问题\n在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，add是在另一个进程中执行的。这就带来了几个新问题：\nCall ID映射。我们怎么告诉远程机器我们要调用add，而不是sub或者Foo呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用add，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 \u0026lt;\u0026ndash;\u0026gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。 解决了上面三个机制，就能实现RPC了，具体过程如下：\nClient端解决的问题：\n将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法 将Call ID，a和b序列化。可以直接将它们的值以二进制形式打包 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层 等待服务器返回结果 如果服务器调用成功，那么就将结果反序列化，并赋给total Server端解决的问题：\n在本地维护一个Call ID到函数指针的映射call_id_map，可以用dict完成 等待请求，包括多线程的并发处理能力 得到一个请求后，将其数据包反序列化，得到Call ID 通过在call_id_map中查找，得到相应的函数指针 将a和rb反序列化后，在本地调用add函数，得到结果 将结果序列化后通过网络返回给Client ​\t在上面的整个流程中，估计有部分同学看到了熟悉的计算机网络的流程和web服务器的定义。\n所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。\n其中：\nCall ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。 实际上真正的开发过程中，除了上面的基本功能以外还需要更多的细节：网络错误、流量控制、超时和重试等。\n# 1.2 使用Http来模拟RPC server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 1. CallID的问题：r.URL.Path, 2. 数据的传输协议：url的参数传递协议， 3. 网络传输协议：http http.HandleFunc(\u0026#34;/add\u0026#34;, func(w http.ResponseWriter, r *http.Request) { _ = r.ParseForm() fmt.Println(r.URL.Path) a, _ := strconv.Atoi(r.Form[\u0026#34;a\u0026#34;][0]) b, _ := strconv.Atoi(r.Form[\u0026#34;b\u0026#34;][0]) w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) jData, _ := json.Marshal(map[string]int{\u0026#34;data\u0026#34;: a + b}) _, _ = w.Write(jData) }) _ = http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } client.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; ) type ResponseData struct { Data int `json:\u0026#34;data\u0026#34;` } func Add(a, b int) int { // 传输协议为：http resp, _ := http.Get(fmt.Sprintf(\u0026#34;http://localhost:8080/%s?a=%d\u0026amp;b=%d\u0026#34;, \u0026#34;add\u0026#34;, a, b)) body, _ := io.ReadAll(resp.Body) fmt.Println(string(body)) respData := \u0026amp;ResponseData{} _ = json.Unmarshal(body, \u0026amp;respData) return respData.Data } func main() { fmt.Println(Add(1, 2)) } # 1.3 RPC开发的四大要素 RPC技术在架构设计上有四部分组成，分别是：客户端、客户端存根、服务端、服务端存根。\n**客户端(Client)：**服务调用发起方，也称为服务消费者。 **客户端存根(Client Stub)：**该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。 **服务端(Server)：**远端的计算机机器上运行的程序，其中有客户端要调用的方法。 **服务端存根(Server Stub)：**接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。 了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：\n两台物理机器在网络中要建立稳定可靠的通信连接。 两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。 在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为：\n1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名； 2、客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。 3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。 4、服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。 5、服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。 6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。 7、服务端Stub程序**将程序调用结果按照约定的协议进行序列化，**并通过网络发送回客户端Stub程序。 8、客户端Stub程序接收到服务端Stub发送的返回数据，**对数据进行反序列化操作，**并将调用返回的数据传递给客户端请求发起者。 9、客户端请求发起者得到调用结果，整个RPC调用过程结束。 RPC需要使用到的术语\n通过上文一系列的文字描述和讲解，我们已经了解了RPC的由来和RPC整个调用过程。我们可以看到RPC是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对RPC中涉及到的技术做一个总结和分析：\n1、动态代理技术： 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。\n2、序列化和反序列化： 在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。\n**序列化：**把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。 **反序列化：**把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 我们常见的Json,XML等相关框架都可以对数据做序列化和反序列化编解码操作。后面我们要学习的Protobuf协议，这也是一种数据编解码的协议，在RPC框架中使用的更广泛。\n# 二、go快速体验RPC和GRPC开发 # 2.1 go快速体验RPC server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; ) type HelloService struct { } func (s *HelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } func main() { // 1. 注册名称为“HelloService”的rpc服务对象（注册处理逻辑 handler） _ = rpc.RegisterName(\u0026#34;HelloService\u0026#34;, \u0026amp;HelloService{}) // 2. 创建监听器 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) // 3. 接受一个连接 conn, _ := listener.Accept() // 4. rpc处理此次连接 rpc.ServeConn(conn) } client.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { // 1. 与服务端建立连接 client, err := rpc.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:1234\u0026#34;) if err != nil { panic(\u0026#34;连接失败\u0026#34;) } var reply string // string 有默认值 // 2. 执行RPC服务端的函数 err = client.Call(\u0026#34;HelloService.Hello\u0026#34;, \u0026#34;bobby\u0026#34;, \u0026amp;reply) if err != nil { panic(\u0026#34;调用失败\u0026#34;) } fmt.Println(reply) } # 2.2 RPC支持JSON ​\t标准库的RPC默认采用Go语言特有的gob编码，因此从其它语言调用Go语言实现的RPC服务将比较困难。在互联网的微服务时代，每个RPC以及服务的使用者都可能采用不同的编程语言，因此跨语言是互联网时代RPC的一个首要条件。得益于RPC的框架设计，Go语言的RPC其实也是很容易实现跨语言支持的。\nGo语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另一个是RPC建立在抽象的io.ReadWriteCloser接口之上的，我们可以将RPC架设在不同的通讯协议之上。这里我们将尝试通过官方自带的net/rpc/jsonrpc扩展实现一个跨语言的PPC。\n首先是基于json编码重新实现RPC服务：\nserver.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) type HelloService struct {} func (s *HelloService) Hello(request string, reply *string) error { *reply = \u0026#34;hello \u0026#34;+ request return nil } func main(){ rpc.RegisterName(\u0026#34;HelloService\u0026#34;, new(HelloService)) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) if err != nil { panic(\u0026#34;启动错误\u0026#34;) } for { conn, err := listener.Accept() if err != nil { panic(\u0026#34;接收\u0026#34;) } go rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) } } ​\t代码中最大的变化是用rpc.ServeCodec函数替代了rpc.ServeConn函数，传入的参数是针对服务端的json编解码器。\nclient.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) func main(){ conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:1234\u0026#34;) if err != nil { panic(\u0026#34;连接错误\u0026#34;) } client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn)) var reply string err = client.Call(\u0026#34;HelloService.Hello\u0026#34;, \u0026#34;imooc\u0026#34;, \u0026amp;reply) if err != nil { panic(\u0026#34;调用错误\u0026#34;) } fmt.Println(reply) } # 2.3 基于HTTP的RPC server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) type HelloService struct { } func (s *HelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } func main() { _ = rpc.RegisterName(\u0026#34;HelloService\u0026#34;, new(HelloService)) http.HandleFunc(\u0026#34;/jsonrpc\u0026#34;, func(w http.ResponseWriter, r *http.Request) { var conn io.ReadWriteCloser = struct { io.Writer io.ReadCloser }{ ReadCloser: r.Body, Writer: w, } _ = rpc.ServeRequest(jsonrpc.NewServerCodec(conn)) }) _ = http.ListenAndServe(\u0026#34;:1234\u0026#34;, nil) } client.go\n使用curl来访问\n1 2 3 4 // 请求格式 curl localhost:1234/jsonrpc -X POST --data \u0026#39;{\u0026#34;method\u0026#34;:\u0026#34;HelloService.Hello\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;bobby\u0026#34;],\u0026#34;id\u0026#34;:0}\u0026#39; # 返回值 {\u0026#34;id\u0026#34;:0,\u0026#34;result\u0026#34;:\u0026#34;Hello bobby\u0026#34;,\u0026#34;error\u0026#34;:null} # 2.4 进一步改进RPC调用过程 ​\t前面的rpc调用虽然简单，但是和普通的http的调用差异不大，这次我们解决下面的问题：\nServiceName统一和名称冲突的问题 只关注业务代码，屏蔽HelloServiceName和Hello函数名称 # 2.4.1 ServiceName统一和名称冲突的问题 server端和client端如何统一serviceName 多个server的包中serviceName同名的问题 新建handler/handler.go文件内容如下： 为什么要新建一个文件？ - 解耦\n1 2 3 package handler const HelloServiceName = \u0026#34;handler/HelloService\u0026#34; server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;base_grpc/handler\u0026#34; ) type HelloService struct { } func (s *HelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } func main() { _ = rpc.RegisterName(handler.HelloServiceName, new(HelloService)) listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) conn, _ := listener.Accept() rpc.ServeConn(conn) } client.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;base_grpc/handler\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { // 1. 建立连接 client, err := rpc.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:1234\u0026#34;) if err != nil { panic(\u0026#34;连接失败\u0026#34;) } var reply string err = client.Call(handler.HelloServiceName+\u0026#34;.Hello\u0026#34;, \u0026#34;bobby\u0026#34;, \u0026amp;reply) if err != nil { panic(\u0026#34;调用失败\u0026#34;) } fmt.Println(reply) } # 2.4.2 继续屏蔽HelloServiceName和Hello函数名称 handler.go\n1 2 3 4 5 6 7 8 9 10 11 12 package handler const HelloServiceName = \u0026#34;handler/HelloService\u0026#34; type NewHelloService struct { } func (s *NewHelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } 服务端代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package server_proxy import ( \u0026#34;net/rpc\u0026#34; ) const HelloServiceName = \u0026#34;HelloService\u0026#34; type HelloServicer interface { Hello(request string, replay *string) error } func RegisterHelloService(srv HelloServicer) error { return rpc.RegisterName(HelloServiceName, srv) } 服务端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;base_grpc/handler\u0026#34; \u0026#34;base_grpc/server_proxy\u0026#34; ) func main() { _ = server_proxy.RegisterHelloService(\u0026amp;handler.NewHelloService{}) listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) conn, _ := listener.Accept() rpc.ServeConn(conn) } 客户端代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package client_proxy import ( \u0026#34;net/rpc\u0026#34; \u0026#34;base_grpc/handler\u0026#34; ) type HelloServiceClientStub struct { *rpc.Client } func NewHelloServiceClientStub(protocol, addr string) *HelloServiceClientStub { client, _ := rpc.Dial(protocol, addr) return \u0026amp;HelloServiceClientStub{client} } func (c HelloServiceClientStub) Hello(request string, replay *string) error { err := c.Client.Call(handler.HelloServiceName+\u0026#34;.Hello\u0026#34;, request, replay) if err != nil { return err } return nil } 客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;base_grpc/client_proxy\u0026#34; ) func main() { // 1. 建立连接 client := client_proxy.NewHelloServiceClientStub(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) var reply string _ = client.Hello(\u0026#34;bobby\u0026#34;, \u0026amp;reply) fmt.Println(reply) } ","date":"2024-05-08T17:00:00+08:00","image":"https://blog.binggao.xyz/img/golang.jpg","permalink":"https://blog.binggao.xyz/p/rpc-grpc-basic/","title":"RPC和GRPC基础知识"}]