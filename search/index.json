[{"content":" # 群晖安装密码库Vaultwarden # 一、安装 打开群晖的【Container Manager】或者是【Docker】，搜索vaultwarden，选择第一个vaultwarden/server镜像进行下载\n在等待下载过程中，先创建好 vaultwarden 数据存放的目录。在File Station里的docker中创建好 vaultwarden 文件夹，并在里面新建data文件夹 。其实这里在根目录新建vaultwarden 文件夹或在其他文件夹里建vaultwarden都不影响。看各位喜好。名称不用vaultwarden也可以。\n回到Container Manager或者Docker套件，运行刚刚下载好的vaultwarden镜像，启用自动重新启动打勾。每次重启群晖后不用手动启动容器里项目。\n点击下一步\n点击添加文件夹。选择你刚才新建的 vaultwarden 文件夹下的data文件夹。\n在后面的红框里输入 /data\n其他都不要改动。点击下一步。点完成。\n现在可以通过群晖IP地址加刚刚的端口访问你的密码库了。因为Bitwarden限制，不能使http登陆Bitwarden密码库。所以要设置反向代理通过https访问。\n# 二、设置 停止容器，然后点击编辑，然后点击高级设置\n往下拉找到环境，点新增。\n禁用新用户注册添加环境变量 SIGNUPS_ALLOWED=false 禁用邀请添加环境变量 INVITATIONS_ALLOWED=false 启用日志记录添加环境变量 LOG_FILE=/data/bitwarden.log 日志级别默认为 “info”，可以参考 bitwarden_rs wiki 更改日志级别。\n如果想要开启管理页面添加环境变量:ADMIN_TOKEN=token str\n环境变量添加完成点击保存,点击右上角的启动。\n","date":"2024-12-12T08:00:00+08:00","image":"https://blog.binggao.xyz/img/synology.jpg","permalink":"https://blog.binggao.xyz/p/synology-vaultwarden/","title":"群晖安装密码库Vaultwarden"},{"content":" # MySQL基础知识 # 1. SQL语言的分类 SQL语言共分为四大类：数据定义语言DDL，数据操纵语言DML，数据查询语言DQL，数据控制语言DCL。\n# 1.1 数据定义语言DDL（Data Definition Language） ​\t数据定义语言DDL用来创建数据库中的各种对象\u0026mdash;\u0026ndash;表、视图、索引、同义词、聚簇等如：CREATE TABLE/VIEW/INDEX/SYN/CLUSTER\n# 1.2 数据操纵语言DML（Data Manipulation Language） ​\t数据操纵语言DML主要有三种形式：\n插入：INSERT 更新：UPDATE 删除：DELETE # 1.3 数据查询语言DQL（Data QueryLanguage） ​\t数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：\nSELECT \u0026lt;字段名表\u0026gt;\nFROM \u0026lt;表或视图名\u0026gt;\nWHERE \u0026lt;查询条件\u0026gt;\n# 1.4 数据控制语言DCL（Data Control Language） 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：\nGRANT：授权。\nROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。\nCOMMIT [WORK]：提交。\n​\t在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。\n(1) 显式提交用COMMIT命令直接完成的提交为显式提交。其格式为：SQL\u0026gt;COMMIT；\n(2) 隐式提交用SQL命令间接完成的提交为隐式提交。这些命令是：ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。\n(3) 自动提交若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：SQL\u0026gt;SET AUTOCOMMIT ON；\nshow命令： show databases; -- 查询所有的数据库 show tables; -- 查询所有的数据表 show engines -- 查询数据库支持的存储引擎 show create table; -- 查看创建表语句 show variables -- 查询系统变量及其值 show variables like \u0026#39;变量名\u0026#39; -- 查询某个系统变量 show tables from 库名 -- 查询指定数据库的表 SELECT VERSION(); -- 查看服务器版本\n# 1.5 MySQL体系结构 # 1.5.1 MySQL服务端的4层结构 连接层 服务层 引擎层 存储层 # 2. 数据定义语言DDL 库和表的管理\n创建：create 修改：alter 删除：drop # 2.1 创建（Create） # 创建数据库设置字符集 CREATE DATABASE test DEFAULT CHARACTER SET utf8mb4 # 案例：库的创建，如果不存在则创建 CREATE DATABASE IF NOT EXISTS test; # 案例创建表 CREATE TABLE IF NOT EXISTS 表名( 。。。。。。 ); # 2.2 修改（Alter） # 2.2.1 库的修改 # 更改库的字符集 ALTER DATABASE 库名 CHARACTER SET utf8mb4; # 2.2.2 表的修改 #1. 修改列名 ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 数据类型; #2. 修改列的类型或约束 ALTER TABLE 表名 MODIFY COLUMN 列名 新数据类型; #3. 添加新列 ALTER TABLE 表名 ADD COLUMN 列名 数据类型 【first|after 列名】; #4. 删除列 ALTER TABLE 表名 DROP COLUMN 列名; #5. 修改表名 ALTER TABLE 表名 RENAME TO 新表名; # 2.3 删除（Drop） #1. 库的删除 DROP DATABASE IF EXISTS 库名; #2. 表的删除 DROP TABLE IF EXISTS 表名; # 2.4 复制（Create） # 1. 仅仅复制表的结构 CREATE TABLE 新表名 LIKE 表名; # 2. 复制表的结构+数据 CREATE TABLE 新表名 SELECT * FROM 表名; # (通过查询语句也可以选择性建表) # 2.5 六大约束 **NOT NULL：**非空约束，用于保证该字段的值不能为空比如：姓名、学号等。 **DEFAULT：**默认值约束，用于保证该字段有默认值比如：性别。 PRIMARY KEY：主键约束，用于保证该字段的值具有唯一性，并且非空比如：学号、员工编号等。 **UNIQUE：**唯一性约束，用于保证该字段的值具有唯一性，可以为空比如：座位号。 CHECK：检查约束【mysql中不支持，不报错但没有效果】。 FOREIGN KEY：外键约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。比如：学生表的专业编号，员工表的部门编号，员工表的工种编号。 # 2.5.1 约束的添加分类 列级分类 六大约束语法上都支持，但外键约束没有效果。\nCREATE TABLE stuinfo ( id INT PRIMARY KEY,#主键约束 stuName VARCHAR(20) NOT NULL,#非空约束 gender CHAR(1) CHECK(gender=\u0026#39;男\u0026#39; OR gender = \u0026#39;女\u0026#39;),#检查约束 seat int UNIQUE,#唯一性约束 age int DEFAULT 18,# 默认值约束 majorId INT REFERENCES major(id)#外键约束 ); 表级分类\n除了非空约束、默认值约束，其他的都支持。\n外键：\n要求在从表设置外键关系。 从表外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求。 主表的关联列必须是一个key（一般是主键或唯一）。 插入数据时，先插入主表，再插入从表。 删除数据时，先删除从表，再删除主表。 # 2.5.2 修改表时添加约束 添加非空约束\nALTER TABLE 表名 MODIFY COLUMN 列名 VARCHAR(20) NOT NULL; 添加默认值约束\nALTER TABLE 表名 MODIFY COLUMN 列名 INT DEFAULT 18; 添加主键约束\n# ①列级约束 ALTER TABLE 表名 MODIFY COLUMN 列名 INT PRIMARY KEY; # ②表级约束 ALTER TABLE 表名 ADD PRIMARY KEY(列名); ALTER TABLE 表名 ADD CONSTRAINT 键名 PRIMARY KEY(列名); 添加唯一性约束\n# ①列级约束 ALTER TABLE 表名 MODIFY COLUMN 列名 INT UNIQUE; # ②表级约束 ALTER TABLE 表名 ADD UNIQUE(列名) ALTER TABLE 表名 ADD CONSTRAINT 键名 UNIQUE(列名); 添加外键约束\nALTER TABLE 表名 ADD CONSTRAINT 键名 FOREIGN KEY(列名) REFERENCES 表名(列名); # 2.5.3 修改表时删除约束 # 1. 删除非空约束 ALTER TABLE 表名 MODIFY COLUMN 列名 VARCHAR(20) NULL; # 2. 删除默认值约束 ALTER TABLE 表名 MODIFY COLUMN 列名 INT; # 3. 删除主键约束 ALTER TABLE 表名 DROP PRIMARY KEY; # 4. 删除唯一性约束 ALTER TABLE 表名 DROP INDEX 键名; # 5. 删除外键约束 ALTER TABLE 表名 DROP FOREIGN KEY 外键名; # 3. 数据操纵语言DML 数据操作语言\n插入：insert 修改：update 删除：delete # 3.1 插入语句Insert 方式一 insert into 表名 (列名,......) values(值1,......) 方式二 insert into 表名set 列名=值,列名=值,...... 两种方式比较：\n方式一支持插入多行，方式二不支持 方式一支持子查询，方式二不支持 # select 查询的结果对应插入到表中 INSERT INTO beauty(id,NAME,phone) SELECT 26,\u0026#39;宋茜\u0026#39;,\u0026#39;118\u0026#39;; # 3.2 修改语句Update 常规用法\nupdate 表名 set 列 = 新值,...... where 筛选条件; 修改多表操作\nsql92语法：\nupdate 表1 别名,表2 别名 set 列=值 where 连接条件 AND 筛选条件 sql99语法：\nupdate 表1 别名 【连接类型】 join 表名2 别名 on 连接条件 set 列 = 值 where 筛选条件 # 3.3 删除语句Delete # 3.3.1 方式一 单表的删除【掌握】\ndelete from 表名 where 筛选条件 多表的删除【补充】\nsql92语法：\ndelete 表1的别名,表2的别名（删除谁的填谁的，都删都填） from 表1 别名,表2 别名 where 连接条件 and 筛选条件 sql99语法：\ndelete 表1的别名,表2的别名（删除谁的填谁的，都删都填） from 表1 别名 【连接类型】 join 表2 别名 on 连接条件 where 筛选条件 案例\n#案例：删除黄晓明的信息以及他女朋友的信息 DELETE be,bo FROM beauty be JOIN boys bo ON be.`boyfriend_id` = bo.`id` WHERE bo.`boyName` = \u0026#39;黄晓明\u0026#39; # 3.3.2 方式二 trunecat table 表名;# 清空数据 说明：\n自增长列重新开始计数。\n没有返回值。\n不能回滚。\n# 4. 数据库查询语言DQL # 4.1 基础查询 语法：\nselect 查询列表 from 表名; 特点：\n查询列表可以是：表中的字段、常量值、表达式、函数。 查询的结果是一个虚拟的表格。 # 查询常量值 SELECT 100; SELECT \u0026#39;john\u0026#39;; ============================================ # 查询表达式 SELECT\t100%98; # ============================================ # 查询函数 SELECT VERSION(); ============================================ # 起别名 SELECT\t100%98 AS \u0026#34;结果\u0026#34;; SELECT 100%98 \u0026#34;结果\u0026#34;; ============================================ # 去重(DISTINCT) SELECT DISTINCT department_id FROM employees; ============================================ # + 号的作用 # mysql中的+号： # 仅仅只有一个功能：运算符 # SELECT 123 + 90; 两个操作数都为数值型，则做加法运算 # SELECT \u0026#39;123\u0026#39; + 90; 其中一方为字符 型，试图将字符型数值转换成数值型 # 如果转换成功，则继续做加法运算 # SELECT \u0026#39;john\u0026#39; + 90; 如果转换失败，则将字符型数值转换成0 # SELECT null + 10; 只要其中一方为null，则结果肯定为null ============================================ # CONCAT()函数 SELECT CONCAT(last_name,first_name) AS \u0026#34;姓名\u0026#34; FROM employees; # 注：只要其中一方为null，则结果肯定为null ============================================ # IFNULL(字段名,替换值)函数 功能：如果为null，结果则替换为后一个参数 ============================================ # ISNULL(字段) # 功能：判断某字段或表达式是否为null，如果是则返回1，否则返回0 # 4.2 条件查询 语法：\n③select 查询列表 ①from 表名 ②where 筛选条件; 分类：\n按条件表达式筛选(=或\u0026lt;\u0026gt;不能判断null值)\n条件运算符：\u0026gt;、\u0026lt;、=、!=、\u0026lt;\u0026gt;、\u0026gt;=、\u0026lt;=、\u0026lt;=\u0026gt;。 \u0026lt;=\u0026gt;安全等于：既可以判断null值又可以判断普通值 按逻辑表达式筛选\n逻辑运算符：and、or、not。 模糊查询\nlike\n通配符：\n% 任意一个字符（包含0个）\n转义WHERE last_name LIKE \u0026#39;_$_%\u0026#39; ESCAPE \u0026#39;$\u0026#39;; 可以判断字符型和数值型\nbetween and\n包含临界值 in\n判断某字段的值是否属于in列表中的某一项 in列表的值类型必须一致或兼容 is null 和is not null\n# 查询员工表的job_id中包含a和e的，并且a在e的前面 SELECT job_id FROM employees WHERE job_id LIKE \u0026#39;%a%e%\u0026#39;; # 4.3 排序查询 语法：\n③select 查询列表 ①from 表 【②where 筛选条件】④order by 排序列表 【asc | desc】 特点：\n默认是升序。 order by 子句中可以支持单个字段、多个字段、表达式、函数、别名。 order by 子句一般是放在查询语句的最后面，limit子句除外。 # 按姓名的长度显示员工的姓名和工资（按函数排序） SELECT LENGTH(last_name) AS 姓名长度,last_name,salary FROM employees ORDER BY 姓名长度 DESC; # 查询员工信息，要求先按工资升序，在按员工编号降序（按多个字段排序） SELECT * FROM employees ORDER BY salary ASC,employee_id DESC; # 4.4 常见函数 调用：\nselect 函数名(实参列表) 【from表】; 分类：\n单行函数（concat、length、ifnull等） 分组函数 功能：做统计使用，又称为统计函数、聚合函数、组函数 # 4.4.1 单行函数-字符函数 # 1. length 获取参数值的字节个数 SELECT LENGTH(\u0026#39;jon\u0026#39;); ============================================ # 2. concat 拼接字符串 SELECT CONCAT(last_name,\u0026#39;_\u0026#39;,first_name) AS \u0026#34;姓名\u0026#34; FROM employees; ============================================ # 3. upper大写 SELECT UPPER(\u0026#39;john\u0026#39;); ============================================ # 4. lower 小写 SELECT LOWER(\u0026#39;John\u0026#39;); ============================================ # 5. substr或者substring截取字符串 注意：索引从1开始的 # 截取从指定索引处后面所有字符 SELECT SUBSTR(\u0026#39;测试数据123\u0026#39;,2) AS \u0026#34;out_put\u0026#34;; # 截取从指定索引处指定字符长度的字符 SELECT SUBSTR(\u0026#39;测试数据123\u0026#39;,1,3) AS \u0026#34;out_put\u0026#34;; # 从1开始向后截取三位 ============================================ ===================案例===================== 姓名中首字符大写，其他字符小写然后用_拼接，显示出来 SELECT CONCAT(UPPER(SUBSTR(first_name,1,1)),LOWER(SUBSTR(first_name,2)),\u0026#39;_\u0026#39;,LOWER(last_name)) FROM employees; ============================================ # 6. instr 返回参数第一次出现的索引，如果找不到返回0 SELECT INSTR(\u0026#39;12345678\u0026#39;,\u0026#39;678\u0026#39;) AS \u0026#34;out_put\u0026#34;; ============================================ # 7. trim 去除前后空格或者指定字符 SELECT TRIM(\u0026#39;a\u0026#39; FROM \u0026#39;a张a三a\u0026#39;) AS \u0026#34;out_put\u0026#34;; # 结果：张a三 ============================================ # 8. lpad 用指定字符实现指定长度的左填充,如果指定长度小于字符则会截断 SELECT LPAD(\u0026#39;测试\u0026#39;,10,\u0026#39;*\u0026#39;) AS \u0026#34;out_put\u0026#34;; ============================================ # 9. rpad 用指定字符实现指定长度的右填充,如果指定长度小于字符则会截断 SELECT RPAD(\u0026#39;测试\u0026#39;,10,\u0026#39;*\u0026#39;) AS \u0026#34;out_put\u0026#34;; =========================================== # 10. replace 全部替换 SELECT REPLACE(\u0026#39;66\u0026#39;,\u0026#39;66\u0026#39;,\u0026#39;88\u0026#39;) AS \u0026#34;out_put\u0026#34;; # 4.4.2 单行函数-数学函数 # 1. round 四舍五入 SELECT ROUND(1.65); # 结果：2 SELECT ROUND(1.65,1); # 小数点后面保留1位:1.7 ============================================ # 2. ceil 向上取整,返回\u0026gt;=该参数的最小整数 SELECT CEIL(1.02); # 结果：2 SELECT CEIL(-1.02); # 结果：-1 ============================================ # 3. floor 向下取整，返回\u0026lt;=该参数的最大整数 SELECT FLOOR(9.99); # 结果：9 SELECT FLOOR(-9.99); # 结果：-10 ============================================ # 4. truncate 截断 SELECT TRUNCATE(1.6999,1); # 结果：1.6 ============================================ # 5. mod 取余 # mod(a,b)：公式：a-b/b*b SELECT MOD(10,3); # 结果：1 SELECT MOD(-10,3); # 结果：-1 # 4.4.3 单行函数-日期函数 # 1. now() 返回当前系统日期+时间 SELECT NOW(); ============================================ # 2. curdate() 返回当前系统日期 SELECT CURDATE(); ============================================ # 3. curtime() 返回当前时间 SELECT CURTIME(); ============================================ # 4. 获取指定的部分，年、月、日、小时、分钟、秒 SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); SELECT HOUR(NOW()); SELECT MINUTE(NOW()); SELECT SECOND(NOW()); # 5. str_to_date 将字符 指定的格式转换成日期 SELECT * FROM employees WHERE hiredate = STR_TO_DATE(\u0026#39;4-3 1992\u0026#39;,\u0026#39;%c-%d %Y\u0026#39;); ============================================ # 6. date_formart 将日期转换为字符串 SELECT DATE_FORMAT(NOW(),\u0026#39;%y年%m月%d日\u0026#39;); ============================================ # 7. datediff SELECT DATEDIFF(NOW(),\u0026#39;1997-01-01\u0026#39;); # 4.4.4 单行函数-流程控制函数 # 1. if函数(类似于三目运算符) SELECT IF(10\u0026gt;5,\u0026#34;大\u0026#34;,\u0026#34;小\u0026#34;); # 结果：大 SELECT last_name,commission_pct,IF(commission_pct IS NULL,\u0026#39;没奖金\u0026#39;,\u0026#39;有奖金\u0026#39;) AS \u0026#34;备注\u0026#34; FROM employees; ============================================ # 2. case函数的使用一： # 语法： CASE 要判断的字段或表达式 WHEN 常量1 THEN 要显示的值1或语句2; WHEN 常量2 THEN 要显示的值2或语句2; ... ELSE 要显示的值n或语句n; END # 案例：查询员工的工资，要求 #\t部门号=30，显示的工资为1.1倍 #\t部门号=40，显示的工资为1.2倍 #\t部门号=50，显示的工资为1.3倍 #\t其他部门，显示的工资为原工资 SELECT salary AS \u0026#34;原始工资\u0026#34;,department_id, CASE department_id WHEN 30 THEN salary*1.1 WHEN 40 THEN salary*1.2 WHEN 50 THEN salary*1.3 ELSE salary END AS \u0026#34;新工资\u0026#34; FROM employees; ============================================ # 3. case函数的使用二：类似于多重if # 语法： CASE WHEN 条件1 THEN 要显示的值1或语句1 WHEN 条件2 THEN 要 显示的值2或语句2 ... ELSE 要显示的值n或语句n END # 案例：查询员工的工资情况 如果工资\u0026gt;20000,显示A级别 如果工资\u0026gt;15000,显示B级别 如果工资\u0026gt;10000,显示C级别 否则，显示D级别 SELECT salary, CASE WHEN salary\u0026gt;20000 THEN \u0026#39;A级别\u0026#39; WHEN salary\u0026gt;15000 THEN \u0026#39;B级别\u0026#39; WHEN salary\u0026gt;10000 THEN \u0026#39;C级别\u0026#39; ELSE \u0026#39;D级别\u0026#39; END AS \u0026#34;工资级别\u0026#34; fromv employees; # 4.4.5 分组函数 分类：\n​\tsum 求和、avg 平均值、max 最大值、min 最小值、count 计算非空个数。\n特点：\nsum、avg一般用于处理数值型m ax、min、count可以处理任何类型 以上分组函数都忽略null值 可以和distinct搭配使用 SELECT SUM(DISTINCT salary) AS \u0026#34;去重\u0026#34;,SUM(salary) AS \u0026#34;没去重\u0026#34; FROM employees; # 4.4.5.1 count函数 统计行数：count(*)只要有一列不为null就会被统计。 效率： MYISAM存储引擎下，count(*) 的效率高。 INNODB存储引擎，count(*)和count(1)的效率差不多，比count(字段)要高一些。 注意：\n​\t和分组函数一同查询的字段要求是group by后的字段\n# 4.5 分组查询 语法：\nselect 分组函数,列（要求出现在group by的后面） from 表 【where 筛选条件】 group by 分组的列表 【having 筛选条件】 【order by 子句】 注意：\n查询列表特殊，要求是分组函数和group by后出现的字段； having字句可以让我们筛选分组之后的各种数据； 分组函数做条件肯定是放在having子句中。 # 4.6 连接查询 SQL92按功能分类\n内连接 等值连接(n表连接，至少需要n-1个连接条件)。 非等值连接 。 自连接。 SQL99按功能分类\n语法:\nselect 查询列表 from 表1 别名 【连接类型】 join 表2 别名 on 连接条件 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序列表】 内连接（inner) # 案例：查询员工名、部门名、工种名，并按部门名降序 # 两表以上连接查询有顺序，前面的两张表会形成一个大表，第三张表的连接条件必须在这张大表里面。 SELECT e.last_name,d.department_name,j.job_title FROM employees e INNER JOIN departments d ON e.`department_id` = d.`department_id` INNER JOIN jobs j ON j.`job_id` = e.`job_id` ORDER BY d.`department_name` DESC; 连接类型：\n等值连接\n非等值连接\n自连接\n外连接 应用场景：用于查询一个表中有，另一个表中没有的记录。\n左外连接（left 【outer】） 右外连接（right【outer】） 全外连接（full【outer】） 交叉连接 # 4.7 子查询 # 4.7.1 含义 出现在其他语句中的select语句，称为子查询或内查询\n外部的查询语句，称为主查询或外查询。\n# 4.7.2 分类 # 4.7.2.1 按子查询出现的位置 select后面\n仅仅支持标量子查询 # 查询每个部门的员工个数 SELECT d.*,( SELECT COUNT(*) FROM employees e WHERE e.department_id = d.`department_id` ) 个数 FROM departments d; from后面\n支持表子查询 # 案例：查询每个部门的平均工资的工资登记 SELECT ag_dep.*,jg.`grade_level` FROM (SELECT AVG(salary) ag, department_id FROM employees GROUP BY department_id ) ag_dep INNER JOIN job_grades jg ON ag_dep.ag BETWEEN jg.`lowest_sal` AND jg.`highest_sal` where或having后面 ★\n标量子查询（单行）√（普通的）\n列子查询（多行）√\n行子查询\nSELECT * FROM employees WHERE (employee_id,salary)=( SELECT MIN(employee_id),MAX(salary) FROM employees ) # 局限性 操作符相同（例如：=） exists后面（相关子查询）\n注意：根据结果true或false来保留结果集\n语法：\nexists(完整的查询语句) 示例：\n# 表子查询 SELECT bo.* FROM boys bo WHERE NOT EXISTS( SELECT * FROM beauty be WHERE be.`boyfriend_id` = bo.`id` ); # 4.7.2.2 按结果集的行列数不同 标量子查询（结果集只有一行一列）。 列子查询（结果集只有一列多行）。 行子查询（结果集只有一行多列）。 表子查询（结果集一般为多行多列）。 # 4.8 分页查询 格式：\nlimit 【offset,】size; # offset 要显示条目的起始索引（起始索引从0开始） # size 要显示的条目个数 公式：\n要显示的页数 page，每页的条目数size\nlimit (currentPage-1)*pageSize,pageSize;\n# 4.9 union联合查询 将多条查询语句的结果合并成一个结果\n语法：\n查询语句1 union 查询语句2 union ... 示例：\nSELECT * FROM employees WHERE email LIKE \u0026#39;%a%\u0026#39; UNION SELECT * FROM employees WHERE department_id \u0026gt; 90; **应用场景：**要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时\n特点：\n要求多条查询语句的查询列数是一致的！ 要求多条查询语句的查询的每一列的类型和顺序最好一致。 union关键字默认去重，如果使用union all 可以包含重复项。 # 4.10 DQL的执行顺序 from join on where group by(开始使用select中的别名，后面的语句中都可以使用) avg,sum\u0026hellip;. having select distinct order by limit # 5. 数据控制语言DCL # 5.1 管理用户 # 5.1.2 查询用户 USE mysql; SELECT * FROM user; # 5.1.3 创建用户 CREATE USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; # 5.1.4 修改用户密码 ALTER USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;新密码\u0026#39;; # 5.1.5 删除用户 DROP USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; 完整示例：\n-- 创建用户test，只能在当前主机localhost访问 create user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; -- 创建用户test，能在任意主机访问 create user \u0026#39;test\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; create user \u0026#39;test\u0026#39; identified by \u0026#39;123456\u0026#39;; -- 修改密码 alter user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified with mysql_native_password by \u0026#39;1234\u0026#39;; -- 删除用户 drop user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39;; # 5.1.6 注意事项 主机名可以使用 % 通配 # 5.2 权限控制 常用权限\n权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 # 5.2.1 查询权限 SHOW GRANTS FOR \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 5.2.2 授予权限 GRANT 权限列表 ON 数据库名.表名 TO \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 5.2.3 撤销权限 REVOKE 权限列表 ON 数据库名.表名 FROM \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 5.2.4 刷新权限 # 使用FLUSH命令刷新MySQL的缓存，包括授权表缓存： FLUSH PRIVILEGES; MySQL权限刷新注意事项：\n刷新权限需要以root用户登录MySQL数据库。\n刷新权限可能会影响MySQL的性能，建议在低峰期进行操作。\n刷新权限后，所有修改的用户权限都会生效，包括新增用户和修改已有用户的权限。\n# 5.2.4 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 # 6. TCL视图控制语言 # 6.1 事务的ACID（acid）属性 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Lsolation） ：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事物是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 # 6.2 事务的创建 # 6.2.1 隐式事务 事务没有明显的开启和结束标记比如：insert、update、delete语句\n# 6.2.2 显式事务 事务具有明显的开启和结束标记，前提：必须先设置自动提交功能为禁用\n# 步骤1：开启事务 set autocommit = 0; # 当前会话有效（默认start transaction） start transaction; # 可选的 # 步骤2：编写事务中的sql语句（select insert update delete） # 语句1; # 语句2; # ... # 步骤3：结束事务 commit; # 提交事务 rollback;# 回滚事务 回滚点：\nset autocommit = 0; start transaction; # 语句1 savepoint 保存点名; # 设置保存点 # 语句2 rollback to 保存点名; # 回滚到保存点 # 6.3 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd\n并发事务隔离级别：\n隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：\nSELECT @@TRANSACTION_ISOLATION; 设置事务隔离级别：\nSET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }; SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效\n# 7. 视图 # 7.1 应用场景 多个地方用到同样的查询结果\n该查询结果使用的sql语句比较复杂\n# 7.2 创建视图 CREATE VIEW 视图名 AS 查询语句... # 7.3 修改视图 方式一、如果存在则修改，不存在则创建\nCREATE OR REPLACE VIEW 视图名 AS 查询语句; 方式二、\nALTER VIEW 视图名 AS 查询语句; # 7.4 删除视图 DROP VIEW 视图名1,视图名2....; # 8. 变量 # 8.1 系统变量 变量由系统提供，不是用户定义，属于服务器层面\n#1、查看所有的系统变量或者会话变量 SHOW GLOBAL|SESSION VARIABLES; #2、查看满足条件的部分系统变量 SHOW GLOBAL|SESSION VARIABLES LIKE \u0026#39;%char%\u0026#39;; #3、查看指定的某个系统变量的值 SELECT @@global|session.系统变量名; #4、为某个系统变量赋值 SET GLOBAL|SESSION 系统变量名 = 值; SET @@global|session.系统变量名 = 值; # 8.2 自定义变量 用户变量：作用域：针对于当前会话（连接）有效，同于会话变量的作用域\n# ①声明并初始化 SET @用户变量名 = 值; SET @用户变量名 := 值; SELECT @用户变量名 := 值; # ②赋值 SET @变量名=值; SELECT 字段 INTO @变量名 FROM 表; # ③查看 SELECT @变量名 局部变量\n作用域：仅仅在定义它的begin end中有效\nbegin end 第一句话\n# ①声明 DECLARE 变量名 类型; DECLARE 变量名 类型 DEFAULT 值; # ②赋值 # 方式一 SET 局部变量名 = 值; SET 局部变量名 := 值; SELECT @局部变量名 := 值; # 方式二 SELECT 字段 INTO 局部变量名 FROM 表; # ③查看 SELECT 局部变量名; # 9. 存储过程 一组预编译好的SQL语句的集合，理解成批处理\n提高代码的重用性 简化操作 减少了编译次数并且减少了和数据库服务器的连接次数，提高效率 **运用场景：**批量的插入、批量的更新\n# 9.1 空参列表 # 空参列表 DELIMITER $ CREATE PROCEDURE myp1() BEGIN INSERT INTO admin(username,`password`) VALUES(\u0026#39;join1\u0026#39;,\u0026#39;00000\u0026#39;),(\u0026#39;lily\u0026#39;,\u0026#39;00000\u0026#39;),(\u0026#39;rose\u0026#39;,\u0026#39;00000\u0026#39;),(\u0026#39;jack\u0026#39;,\u0026#39;00000\u0026#39;),(\u0026#39;tom\u0026#39;,\u0026#39;00000\u0026#39;); END $ # 调用 CALL myp1() # 9.2 in模式参数的存储过程 # 创建带in模式参数的存储过程 # 案例：创建存储过程实现根据女神名，查询对应的男神信息 DELIMITER $ CREATE PROCEDURE myp1(IN beautyname VARCHAR(20)) BEGIN SELECT bo.* FROM beauty b RIGHT JOIN boys bo ON b.boyfriend_id = bo.id WHERE b.name = beautyname; END $ # 调用 CALL myp1(\u0026#39;小昭\u0026#39;); # 9.3 out模式参数的存储过程 DELIMITER $ CREATE PROCEDURE save3(IN beatyName VARCHAR(20),OUT boyName VARCHAR(20),OUT userCP INT) BEGIN SELECT bo.boyName,bo.userCP INTO boyName,userCP FROM beauty be INNER JOIN boys bo ON be.boyfriend_id = bo.id WHERE be.name = beatyName; END $ # 调用 CALL save3(\u0026#39;小昭\u0026#39;,@bName,@userC); SELECT @bName,@userC; # 9.4 inout模式参数的存储过程 DELIMITER $ CREATE PROCEDURE save3(INOUT a INT,INOUT b INT) BEGIN SET a := a*2; SET b := b*2; END $ # 调用 SET @a := 10; SET @b := 20; CALL save3(@a,@b); SELECT @a,@b; # 9.5 删除存储过程 DROP PROCEDURE 存储过程名称; # 9.6 查看存储过程结构 SHOW CREATE PROCEDURE 存储过程名称; # 10. 函数 有且仅有一个返回\n运用场景：适合做处理数据后返回一个结果\n# 10.1 创建函数 # 创建语法 DELIMITER $ CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型 BEGIN 函数体 END $ 案例说明：\n#案例：根据部门名，返回该部门的平均工资 DELIMITER $ CREATE FUNCTION myf1(depName VARCHAR(20)) RETURNS DOUBLE BEGIN DECLARE result DOUBLE DEFAULT 0.00; SELECT AVG(e.salary) INTO result FROM employees e INNER JOIN departments d ON e.department_id = d.department_id WHERE d.department_name = depName; RETURN result; END $ # 调用 SELECT myf1(\u0026#39;IT\u0026#39;); # 10.2 查看函数 SHOW CREATE FUNCTION 函数名称 # 10.3 删除函数 DROP FUNCTION 函数名; # 11. 流程控制语句 # 11.1 分支结构 # 语法： IF 条件1 THEN 语句1; ELSEIF 条件2 THEN 语句2; ... 【else 语句n;】 END IF; #应用在 begin end中 # 11.2 循环结构 循环控制：\niterate 类似于continue\nleave 类似于 break\nwhile 循环结构\n# 语法 【标签:】 WHILE 循环条件 DO 循环体; END WHILE 【标签】; loop 循环结构\n【标签:】 LOOP 循环体; END LOOP 【标签】; #可以用来模拟简单的死循环 repeat 循环结构\n【标签:】 REPEAT 循环体; UNTIL 结束循环的条件 END REPEAT 【标签】; # 类似于 do while ，至少执行一次; # 12. 存储引擎 ​\t存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是库的，所以存储引擎也可以被称为表类型。\n# 12.1 基本操作 CREATE TABLE my_innodb( id bigint(20) PRIMARY KEY; )ENGINE INNODB; # 12.2 InnoDB存储引擎 # 12.2.1 介绍 ​\tInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。\n# 12.2.2 特点 DML操作遵循ACID模型，支持事务；\n行级锁，提高高并发访问性能；\n支持外键约束FOREIGN KEY 约束，保持数据的完整性和正确性；\n# 12.2.3 文件 xxx.ibd：xxx代表的是表名，innoDB引擎的每一张表都会对应这样的一个表空间文件，存储该表结构（frm、sdi）、数据和索引。\n配置文件参数：innodb_file_per_table\n# 12.2.4 逻辑存储结构 # 13. 索引 # 13.1 索引的概述 # 13.1.1 介绍 ​\t索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n# 13.1.2 优缺点 优势 劣势 提高数据检索的效率，降低数据库的IO成本 索引列也是要占用磁盘空间的 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。 # 13.2 索引的结构 数据结构动画：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\nMySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：\n索引结构 描述 B+Tree索引 最常见的索引类型，大部分引擎都支持B+树索引 Hash索引 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree（空间索引） 空间索引是MyISAM引擎的特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-text（全文索引） 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，Elasticsearch # 13.2.1 二叉树 # 13.2.2 Btree # 13.2.3 B+Tree # 13.2.4 面试题 问：为什么InnoDB存储引擎选择使用B+tree索引结构\n相对于二叉树，层级更少，搜索效率高； 对于B-Tree，无论是叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低； 相对于Hash索引，B+tree支持范围匹配及排序操作； # 13.3 索引的分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n分类 含义 特点 聚集索引（Clustered Index） 将数据存储与索引放到一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引（Secondary Index） 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 聚集索引选取规：\n如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。 回表查询\n# 13.4 索引的语法 # 13.4.1 创建索引 # 1. 1个索引关联一个字段称为：单列索引 # 2. 1个索引关联多个字段称为：联合（组合）索引 # 3. 索引类型不指定就是普通 CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...); # 13.4.2 查看索引 SHOW INDEX FROM table_name; # 13.4.3 删除索引 DROP INDEX index_name ON table_name; # 13.5 SQL性能分析 # 13.5.1 SQL 执行频率 ​\tMySQL 客户端连接成功后，通过SHOW [SESSION|GLOBAL] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\nSHOW GLOBAL STATUS LIKE \u0026#39;COM_______\u0026#39;; # 13.5.2 慢查询日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf)中配置如下信息：\n# 开启MySQL慢日志查询开关 slow_query_long=1 # 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2 配置完毕之后，通过以下指重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log\n# 13.5.3 profile详情 SHOW profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：\nSELECT @@have_profiling; 默认是关闭的，可以通过set语句在SESSION/GLOBAL级别开启profiling：\n# 1. 查看 SELECT @@profiling; # 2. 设置 SET profiling=1; 执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n# 查看每一条SQL的耗时基本情况 SHOW profiles; # 查看指定query_id的SQL语句各个阶段的耗时情况 SHOW profile FOR QUERY query_id; # 查看指定query_id的SQL语句CPU的使用情况 SHOW profile CPU FOR QUERY query_id; # 13.5.4 explain执行计划 EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。\n语法：\n# 直接再SELECT语句之前加上关键字EXPLAIN/DESC EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件; EXPLAIN 执行计划各字段含义：\nid\nselect查询的序列号，表示查询中执行select子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。\nselect_type\n表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。\ntype\n表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。\npossible_key\n显示可能应用在这张表上的索引，一个或多个。\nKey\n实际使用的索引，如果为NULL，则没有使用索引。\nKey_len\n表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。\nrows\nMySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的。\nfiltered\n表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。\n# 13.6 索引的使用 # 13.6.1 联合索引-最左前缀法则 ​\t如果索引了多列（联合索引），要遵循最左前缀法则。最左前缀法则。最左前缀法则指的是查询是从索引的最左列开始，并且不跳过索引中的列。\n​\t如果跳跃某一列，索引将部分失效（后面的字段索引失效）\n# 13.6.2 索引失效 # 13.6.2.1 范围查询 联合索引中，出现范围查询（\u0026gt;,\u0026lt;），范围查询右侧的列索引失效。可以用\u0026gt;=或者\u0026lt;=来规避索引失效问题。\n# 13.6.2.2 索引列运算 不要在索引列上进行运算操作，索引将失效\n# 13.6.2.3 字符串不加引号 字符串类型字段使用时，不加引号，索引将失效。（隐式转换问题）\n# 13.6.2.4 模糊查询 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\n# 13.6.2.5 OR连接的条件 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。两边都有索引才会走索引（全真为真）。\n需要对age单独建立索引\n# 13.6.2.6 数据分布影响 如果MySQL评估使用索引比全表更慢，则不使用索引。\nmysq优化器会自动选择最优\n# 13.6.3 SQL提示 SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\nuse index：建议使用索引 ignore index：忽略该索引 force index：强制使用该索引 # 13.6.4 覆盖索引 ​\t覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要去查询主键索引中的记录，避免了回表的产生，减少了树的搜索次数，显著提升性能。\n尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少SELECT *。\n# 13.6.5 前缀索引 当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以节约索引空间，从而提高索引效率。\n语法\n# n取前几个字符 CREATE INDEX idx_xxx ON table_name(column(n)); 前缀长度\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\nSELECT COUNT(DISTINCT email)/COUNT(*) FROM tb_user; SELECT COUNT(DISTINCT SUBSTRING(email,1,5))/COUNT(*) FROM tb_user; # 13.6.6 单列索引\u0026amp;联合索引 单列索引：即一个索引只包含单个列。\n联合索引：即一个索引包含了多个列。\n在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n联合索引情况\n# 13.7 索引的设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 # 14. SQL优化 # 14.1 插入数据优化 # 14.1.1 普通插入 采用批量插入（一次插入的数据不建议超过500条或1000条） 手动提交事务 主键顺序插入 # 14.1.2 大批量插入 如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。\n# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入） mysql --local-infile -u root -p # 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 set global local_infile = 1; select @@local_infile; # 执行load指令将准备好的数据，加载到表结构中 load data local infile \u0026#39;/root/sql1.log\u0026#39; into table \u0026#39;tb_user\u0026#39; fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;; # 14.2 主键优化 # 14.2.1 数据组织方式 在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）\n页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。 页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 ​\tMERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定\n*文字说明不够清晰明了，具体可以看视频里的PPT演示过程：*https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90\n# 14.2.2 主键设计原则 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 # 14.3 Order By 优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 ​\t如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引。\n总结：\n根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） # 14.4 Group By 优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是要满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则\n# 14.5 Limit优化 ​\t常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。 ​\t优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。\n例如：\n# 此语句耗时很长 select * from tb_sku limit 9000000, 10; # 通过覆盖索引加快速度，直接通过主键索引进行排序及查询 select id from tb_sku order by id limit 9000000, 10; # 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit # select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10); # 通过连表查询即可实现第一句的效果，并且能达到第二句的速度 select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; # 14.6 Count优化 count的几种用法 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count()一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count()一样；count(null)返回0 各种用法的性能 count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序： count(字段) \u0026lt; count(主键) \u0026lt; count(1) \u0026lt; count(*)，所以尽量使用 count(*) # 14.7 Update优化（避免行锁升级为表锁） InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n如以下两条语句： update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行； update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引\n","date":"2024-06-18T17:00:00+08:00","image":"https://blog.binggao.xyz/img/mysql.jpg","permalink":"https://blog.binggao.xyz/p/mysql-basic/","title":"MySQL基础知识"},{"content":" # RPC和GRPC基础知识 # 一、基础 # 1.1 概念 RPC（Remote Procedure Call） 远程过程调用。 RPC是一种通过网络从远程计算机程序上请求服务，不需要了解底层网络技术的协议。 RPC主要作用就是不同的服务间方法调用就像本地调用一样便捷。 本地调用转变为远程过程调用带来的问题\n在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，add是在另一个进程中执行的。这就带来了几个新问题：\nCall ID映射。我们怎么告诉远程机器我们要调用add，而不是sub或者Foo呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用add，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 \u0026lt;\u0026ndash;\u0026gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。 解决了上面三个机制，就能实现RPC了，具体过程如下：\nClient端解决的问题：\n将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法 将Call ID，a和b序列化。可以直接将它们的值以二进制形式打包 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层 等待服务器返回结果 如果服务器调用成功，那么就将结果反序列化，并赋给total Server端解决的问题：\n在本地维护一个Call ID到函数指针的映射call_id_map，可以用dict完成 等待请求，包括多线程的并发处理能力 得到一个请求后，将其数据包反序列化，得到Call ID 通过在call_id_map中查找，得到相应的函数指针 将a和rb反序列化后，在本地调用add函数，得到结果 将结果序列化后通过网络返回给Client ​\t在上面的整个流程中，估计有部分同学看到了熟悉的计算机网络的流程和web服务器的定义。\n所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。\n其中：\nCall ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。 实际上真正的开发过程中，除了上面的基本功能以外还需要更多的细节：网络错误、流量控制、超时和重试等。\n# 1.2 使用Http来模拟RPC server.go\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 1. CallID的问题：r.URL.Path, 2. 数据的传输协议：url的参数传递协议， 3. 网络传输协议：http http.HandleFunc(\u0026#34;/add\u0026#34;, func(w http.ResponseWriter, r *http.Request) { _ = r.ParseForm() fmt.Println(r.URL.Path) a, _ := strconv.Atoi(r.Form[\u0026#34;a\u0026#34;][0]) b, _ := strconv.Atoi(r.Form[\u0026#34;b\u0026#34;][0]) w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) jData, _ := json.Marshal(map[string]int{\u0026#34;data\u0026#34;: a + b}) _, _ = w.Write(jData) }) _ = http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } client.go\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; ) type ResponseData struct { Data int `json:\u0026#34;data\u0026#34;` } func Add(a, b int) int { // 传输协议为：http resp, _ := http.Get(fmt.Sprintf(\u0026#34;http://localhost:8080/%s?a=%d\u0026amp;b=%d\u0026#34;, \u0026#34;add\u0026#34;, a, b)) body, _ := io.ReadAll(resp.Body) fmt.Println(string(body)) respData := \u0026amp;ResponseData{} _ = json.Unmarshal(body, \u0026amp;respData) return respData.Data } func main() { fmt.Println(Add(1, 2)) } # 1.3 RPC开发的四大要素 RPC技术在架构设计上有四部分组成，分别是：客户端、客户端存根、服务端、服务端存根。\n**客户端(Client)：**服务调用发起方，也称为服务消费者。 **客户端存根(Client Stub)：**该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。 **服务端(Server)：**远端的计算机机器上运行的程序，其中有客户端要调用的方法。 **服务端存根(Server Stub)：**接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。 了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：\n两台物理机器在网络中要建立稳定可靠的通信连接。 两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。 在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为：\n1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名； 2、客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。 3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。 4、服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。 5、服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。 6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。 7、服务端Stub程序**将程序调用结果按照约定的协议进行序列化，**并通过网络发送回客户端Stub程序。 8、客户端Stub程序接收到服务端Stub发送的返回数据，**对数据进行反序列化操作，**并将调用返回的数据传递给客户端请求发起者。 9、客户端请求发起者得到调用结果，整个RPC调用过程结束。 RPC需要使用到的术语\n通过上文一系列的文字描述和讲解，我们已经了解了RPC的由来和RPC整个调用过程。我们可以看到RPC是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对RPC中涉及到的技术做一个总结和分析：\n1、动态代理技术： 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。\n2、序列化和反序列化： 在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。\n**序列化：**把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。 **反序列化：**把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 我们常见的Json,XML等相关框架都可以对数据做序列化和反序列化编解码操作。后面我们要学习的Protobuf协议，这也是一种数据编解码的协议，在RPC框架中使用的更广泛。\n# 二、go快速体验RPC和GRPC开发 # 2.1 go快速体验RPC server.go\npackage main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; ) type HelloService struct { } func (s *HelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } func main() { // 1. 注册名称为“HelloService”的rpc服务对象（注册处理逻辑 handler） _ = rpc.RegisterName(\u0026#34;HelloService\u0026#34;, \u0026amp;HelloService{}) // 2. 创建监听器 listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) // 3. 接受一个连接 conn, _ := listener.Accept() // 4. rpc处理此次连接 rpc.ServeConn(conn) } client.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { // 1. 与服务端建立连接 client, err := rpc.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:1234\u0026#34;) if err != nil { panic(\u0026#34;连接失败\u0026#34;) } var reply string // string 有默认值 // 2. 执行RPC服务端的函数 err = client.Call(\u0026#34;HelloService.Hello\u0026#34;, \u0026#34;bobby\u0026#34;, \u0026amp;reply) if err != nil { panic(\u0026#34;调用失败\u0026#34;) } fmt.Println(reply) } # 2.2 RPC支持JSON ​\t标准库的RPC默认采用Go语言特有的gob编码，因此从其它语言调用Go语言实现的RPC服务将比较困难。在互联网的微服务时代，每个RPC以及服务的使用者都可能采用不同的编程语言，因此跨语言是互联网时代RPC的一个首要条件。得益于RPC的框架设计，Go语言的RPC其实也是很容易实现跨语言支持的。\nGo语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另一个是RPC建立在抽象的io.ReadWriteCloser接口之上的，我们可以将RPC架设在不同的通讯协议之上。这里我们将尝试通过官方自带的net/rpc/jsonrpc扩展实现一个跨语言的PPC。\n首先是基于json编码重新实现RPC服务：\nserver.go\npackage main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) type HelloService struct {} func (s *HelloService) Hello(request string, reply *string) error { *reply = \u0026#34;hello \u0026#34;+ request return nil } func main(){ rpc.RegisterName(\u0026#34;HelloService\u0026#34;, new(HelloService)) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) if err != nil { panic(\u0026#34;启动错误\u0026#34;) } for { conn, err := listener.Accept() if err != nil { panic(\u0026#34;接收\u0026#34;) } go rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) } } ​\t代码中最大的变化是用rpc.ServeCodec函数替代了rpc.ServeConn函数，传入的参数是针对服务端的json编解码器。\nclient.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) func main(){ conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:1234\u0026#34;) if err != nil { panic(\u0026#34;连接错误\u0026#34;) } client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn)) var reply string err = client.Call(\u0026#34;HelloService.Hello\u0026#34;, \u0026#34;imooc\u0026#34;, \u0026amp;reply) if err != nil { panic(\u0026#34;调用错误\u0026#34;) } fmt.Println(reply) } # 2.3 基于HTTP的RPC server.go\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) type HelloService struct { } func (s *HelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } func main() { _ = rpc.RegisterName(\u0026#34;HelloService\u0026#34;, new(HelloService)) http.HandleFunc(\u0026#34;/jsonrpc\u0026#34;, func(w http.ResponseWriter, r *http.Request) { var conn io.ReadWriteCloser = struct { io.Writer io.ReadCloser }{ ReadCloser: r.Body, Writer: w, } _ = rpc.ServeRequest(jsonrpc.NewServerCodec(conn)) }) _ = http.ListenAndServe(\u0026#34;:1234\u0026#34;, nil) } client.go\n使用curl来访问\n// 请求格式 curl localhost:1234/jsonrpc -X POST --data \u0026#39;{\u0026#34;method\u0026#34;:\u0026#34;HelloService.Hello\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;bobby\u0026#34;],\u0026#34;id\u0026#34;:0}\u0026#39; # 返回值 {\u0026#34;id\u0026#34;:0,\u0026#34;result\u0026#34;:\u0026#34;Hello bobby\u0026#34;,\u0026#34;error\u0026#34;:null} # 2.4 进一步改进RPC调用过程 ​\t前面的rpc调用虽然简单，但是和普通的http的调用差异不大，这次我们解决下面的问题：\nServiceName统一和名称冲突的问题 只关注业务代码，屏蔽HelloServiceName和Hello函数名称 # 2.4.1 ServiceName统一和名称冲突的问题 server端和client端如何统一serviceName 多个server的包中serviceName同名的问题 新建handler/handler.go文件内容如下： 为什么要新建一个文件？ - 解耦\npackage handler const HelloServiceName = \u0026#34;handler/HelloService\u0026#34; server.go\npackage main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;base_grpc/handler\u0026#34; ) type HelloService struct { } func (s *HelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } func main() { _ = rpc.RegisterName(handler.HelloServiceName, new(HelloService)) listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) conn, _ := listener.Accept() rpc.ServeConn(conn) } client.go\npackage main import ( \u0026#34;base_grpc/handler\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { // 1. 建立连接 client, err := rpc.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:1234\u0026#34;) if err != nil { panic(\u0026#34;连接失败\u0026#34;) } var reply string err = client.Call(handler.HelloServiceName+\u0026#34;.Hello\u0026#34;, \u0026#34;bobby\u0026#34;, \u0026amp;reply) if err != nil { panic(\u0026#34;调用失败\u0026#34;) } fmt.Println(reply) } # 2.4.2 继续屏蔽HelloServiceName和Hello函数名称 handler.go\npackage handler const HelloServiceName = \u0026#34;handler/HelloService\u0026#34; type NewHelloService struct { } func (s *NewHelloService) Hello(request string, reply *string) error { // 返回值是通过修改reply的值 *reply = \u0026#34;Hello \u0026#34; + request return nil } 服务端代理\npackage server_proxy import ( \u0026#34;net/rpc\u0026#34; ) const HelloServiceName = \u0026#34;HelloService\u0026#34; type HelloServicer interface { Hello(request string, replay *string) error } func RegisterHelloService(srv HelloServicer) error { return rpc.RegisterName(HelloServiceName, srv) } 服务端\npackage main import ( \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;base_grpc/handler\u0026#34; \u0026#34;base_grpc/server_proxy\u0026#34; ) func main() { _ = server_proxy.RegisterHelloService(\u0026amp;handler.NewHelloService{}) listener, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) conn, _ := listener.Accept() rpc.ServeConn(conn) } 客户端代理\npackage client_proxy import ( \u0026#34;net/rpc\u0026#34; \u0026#34;base_grpc/handler\u0026#34; ) type HelloServiceClientStub struct { *rpc.Client } func NewHelloServiceClientStub(protocol, addr string) *HelloServiceClientStub { client, _ := rpc.Dial(protocol, addr) return \u0026amp;HelloServiceClientStub{client} } func (c HelloServiceClientStub) Hello(request string, replay *string) error { err := c.Client.Call(handler.HelloServiceName+\u0026#34;.Hello\u0026#34;, request, replay) if err != nil { return err } return nil } 客户端\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;base_grpc/client_proxy\u0026#34; ) func main() { // 1. 建立连接 client := client_proxy.NewHelloServiceClientStub(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) var reply string _ = client.Hello(\u0026#34;bobby\u0026#34;, \u0026amp;reply) fmt.Println(reply) } ","date":"2024-05-18T17:00:00+08:00","image":"https://blog.binggao.xyz/img/golang.jpg","permalink":"https://blog.binggao.xyz/p/rpc-grpc-basic/","title":"RPC和GRPC基础知识"},{"content":" # Nginx生成自签名证书 # 一、生成根证书私钥和根证书 使用指定-subj “/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization”,生成根证书私钥和根证书\nopenssl req -x509 -nodes -days 36500 -newkey rsa:2048 -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization\u0026#34; -keyout CA-private.key -out CA-certificate.crt -reqexts v3_req -extensions v3_ca # 二、生成自签名证书私钥 openssl genrsa -out private.key 2048 # 三、根据自签名证书私钥生成自签名证书申请文件 openssl req -new -key private.key -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization/CN=192.168.60.68\u0026#34; -sha256 -out private.csr # 四、定义自签名证书扩展文件(解决chrome安全告警) ​\t定义自签名证书扩展文件(解决Chrome安全告警)。在默认情况下生成的证书一旦选择信任，在 Edge, Firefox 等浏览器都显示为安全，但是Chrome仍然会标记为不安全并警告拦截，这是因为 Chrome 需要证书支持扩展 Subject Alternative Name, 因此生成时需要特别指定 MyExt 扩展并添加相关参数,将下述内容放到一个文件中,命名为private.ext\ncat \u0026gt; private.ext \u0026lt;\u0026lt; EOF [ req ] default_bits = 1024 distinguished_name = req_distinguished_name req_extensions = MyExt extensions = MyExt [ req_distinguished_name ] countryName = CN stateOrProvinceName = BeiJing localityName = BeiJing organizationName = MyOrganization [MyExt] authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = IP:192.168.60.68 EOF # 五、生成自签名证书 ##设置100年的证书有效期 openssl x509 -req -days 36500 -in private.csr -CA CA-certificate.crt -CAkey CA-private.key -CAcreateserial -sha256 -out private.crt -extfile private.ext -extensions MyExt # 六、配置Nginx 将上面生成的private.crt和private.key放在nginx下的ssl目录\n# 七、客户端安装根证书 把该证书CA-certificate.crt安装到受信任的根证书颁发机构下\n","date":"2024-05-09T17:00:00+08:00","image":"https://blog.binggao.xyz/img/nginx.jpg","permalink":"https://blog.binggao.xyz/p/nginx-openssl-self-signed-certificate/","title":"Nginx生成自签名证书"},{"content":" # 一、Docker安装密码管理器Vaultwarden # 1.1 创建专用网络 docker network create middleware # 1.2 准备工作 cd / mkdir mydata mkdir -p mydata/vaultwarden/data mkdir -p mydata/nginx/conf mkdir -p mydata/nginx/ssl # 1.3 安装vaultwarden docker run -d \\ --name vaultwarden \\ -e INVITATIONS_ALLOWED=false \\ -e ADMIN_TOKEN=token123456 \\ -e TZ=Asia/Shanghai \\ -p 8001:80 \\ --network middleware \\ -v /mydata/vaultwarden/data:/data/ \\ --log-driver json-file \\ --log-opt max-size=200k \\ --log-opt max-file=10 \\ vaultwarden/server:latest # 1.3.1 关闭新注册 注册完管理员账号后进入/admin，将`Allow new signups`选项设置为false。 # 1.4 安装nginx # 1.4.1 生成自签名证书 生成根证书私钥和根证书 使用指定-subj “/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization”,生成根证书私钥和根证书\nopenssl req -x509 -nodes -days 36500 -newkey rsa:2048 -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization\u0026#34; -keyout CA-private.key -out CA-certificate.crt -reqexts v3_req -extensions v3_ca 生成自签名证书私钥 openssl genrsa -out private.key 2048 根据自签名证书私钥生成自签名证书申请文件 openssl req -new -key private.key -subj \u0026#34;/C=CN/ST=beijing/L=beijing/O=MyOrganization/CN=192.168.60.68\u0026#34; -sha256 -out private.csr 定义自签名证书扩展文件(解决Chrome安全告警) ​\t定义自签名证书扩展文件(解决Chrome安全告警)。在默认情况下生成的证书一旦选择信任，在 Edge, Firefox 等浏览器都显示为安全，但是Chrome仍然会标记为不安全并警告拦截，这是因为 Chrome 需要证书支持扩展 Subject Alternative Name, 因此生成时需要特别指定 MyExt 扩展并添加相关参数,将下述内容放到一个文件中,命名为private.ext\ncat \u0026gt; private.ext \u0026lt;\u0026lt; EOF [ req ] default_bits = 1024 distinguished_name = req_distinguished_name req_extensions = MyExt extensions = MyExt [ req_distinguished_name ] countryName = CN stateOrProvinceName = BeiJing localityName = BeiJing organizationName = MyOrganization [MyExt] authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = IP:192.168.60.68 EOF 生成自签名证书 ##设置100年的证书有效期 openssl x509 -req -days 36500 -in private.csr -CA CA-certificate.crt -CAkey CA-private.key -CAcreateserial -sha256 -out private.crt -extfile private.ext -extensions MyExt 配置Nginx ​\t将上面生成的private.crt和private.key放在nginx下的ssl目录\n客户端安装根证书 ​\t把该证书CA-certificate.crt安装到受信任的根证书颁发机构下\n# 1.4.2 创建配置文件 打开配置文件 vim /mydata/nginx/conf/nginx.conf 输入以下内容 worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } server { listen 443 ssl; # server_name your_domain.com; # 替换为你的域名 ssl_certificate /etc/ssl/certs/certificate.pem; ssl_certificate_key /etc/ssl/certs/private-key.pem; ssl_protocols TLSv1.2 TLSv1.3; location / { proxy_pass http://vaultwarden:80; # Vaultwarden的地址和端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } } # 1.4.3 运行nginx docker run -d --name nginx \\ --network middleware \\ -v /mydata/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \\ -v /mydata/nginx/ssl:/etc/ssl/certs \\ -p 8080:80 \\ -p 8081:443 \\ nginx:latest ","date":"2024-05-08T17:00:00+08:00","image":"https://blog.binggao.xyz/img/docker.jpg","permalink":"https://blog.binggao.xyz/p/docker-vaultwarden/","title":"Docker安装密码管理器Vaultwarden"},{"content":" # React 18 基础 # 一、React项目结构 # 1. 清理文件 # 二、JSX基础 # 1. 识别js表达式 在JSX中可以通过 大括号语法{} 识别 JavaScript中的表达式，比如常见的变量、函数调用、方法调用等等。\n使用引号传递字符串\n使用JavaScript变量\n函数调用和方法调用\n使用JavaScript对象\nApp.js\nconst count = 100; function getName(){ return \u0026#39;react\u0026#39;; } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is react App {/* 使用引号传递字符串 */} {\u0026#39;this is mesages\u0026#39;} {/* 识别js变量 */} {count} {/* 函数调用 */} {getName()} {/* 方法调用 */} {new Date().getDate()} {/* 使用js对象 */} \u0026lt;div style={{color:\u0026#39;red\u0026#39;}}\u0026gt;this is div\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 注意：if语句、switch语句、变量声明属于语句，不是表达式，不能出现在{}中\n# 2. JSX中实现列表渲染 语法：在JSX中可以使用原生JS中的map方法遍历渲染列表\nApp.js\nconst list= [ {id:1001,name:\u0026#39;Vue\u0026#39;}, {id:1002,name:\u0026#39;React\u0026#39;}, {id:1003,name:\u0026#39;Angular\u0026#39;}, ] function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 渲染列表 */} {/* map 循环哪个结构 return结构 */} {/* 注意事项：加上一个独一无二的key、字符串或者number */} {/* key的作用：React框架内部使用，提升更新性能的 */} \u0026lt;ul\u0026gt; {list.map(item=\u0026gt;\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; # 3. 条件渲染 语法：在React中，可以通过逻辑与运算符\u0026amp;\u0026amp;、三元表达式（?:）实现基础的条件渲染\nApp.js\nconst isLogin = true; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 逻辑与 \u0026amp;\u0026amp; */} {isLogin\u0026amp;\u0026amp;\u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt;} {/* 三元运算 */} {isLogin ? \u0026lt;span\u0026gt;jack\u0026lt;/span\u0026gt;:\u0026lt;span\u0026gt;loading\u0026lt;/span\u0026gt;} \u0026lt;/div\u0026gt; ); } export default App; # 4. 复杂条件渲染 App.js\nconst articleType = 2; // 0 1 3 //定义核心函数（根据文章类型返回不同的JSX模板 function getArticleTem() { if (articleType === 0) { return \u0026lt;div\u0026gt;我是无图模式\u0026lt;/div\u0026gt;; } else if (articleType === 1) { return \u0026lt;div\u0026gt;我是单图模式\u0026lt;/div\u0026gt;; } else { return \u0026lt;div\u0026gt;我是三图模式\u0026lt;/div\u0026gt;; } } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 调用函数渲染不同的模板 */} {getArticleTem()} \u0026lt;/div\u0026gt; ); } export default App; # 5. React中的事件绑定 语法：on + 事件名称 = { 事件处理程序 }，整体上遵循驼峰命名法\nApp.js\nfunction App() { const clickHandler1 = (e)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,e); } const clickHandler2 = (param)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,param); } const clickHandler3 = (param,e)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,param,e); } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={clickHandler1}\u0026gt;click me1\u0026lt;/button\u0026gt; \u0026lt;button onClick={()=\u0026gt;clickHandler2(\u0026#39;jack\u0026#39;)}\u0026gt;click me2\u0026lt;/button\u0026gt; \u0026lt;button onClick={(e)=\u0026gt;clickHandler3(\u0026#39;jack\u0026#39;,e)}\u0026gt;click me3\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 6. React中的组件 概念：一个组件就是用户界面的一部分，它可以有自己的逻辑和外观，组件之间可以互相嵌套，也可以复用多次\n组件化开发可以让开发者像搭积木一样构建一个完整的庞大的应用。\n# 6.1 React组件 在React中，一个组件就是首字母大写的函数，内部存放了组件的逻辑和视图UI, 渲染组件只需要把组件当成标签书写即可。\nApp.js\nfunction Button(){ // 业务逻辑组件逻辑 return \u0026lt;button\u0026gt;click me!\u0026lt;/button\u0026gt; } function App() { return ( \u0026lt;\u0026gt; {/* 自闭和 */} \u0026lt;Button/\u0026gt; {/* 成对标签 */} \u0026lt;Button\u0026gt;\u0026lt;/Button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 7. useState useState 是一个 React Hook（函数），它允许我们向组件添加一个状态变量, 从而控制影响组件的渲染结果。\n# 7.1 useState基础使用 App.js\nimport { useState } from \u0026#34;react\u0026#34;; function App() { // 1. 调用useState 添加一个状态变量 // count 状态变量 // setCount 修改状态变量的方法 const [count,setCount] = useState(0) // 2. 点击事件回调 const clickHandlerCallback=()=\u0026gt;{ // 作用1. 用传入的新值需改count // 2.重新使用新的count渲染ui setCount(count+1) } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={clickHandlerCallback}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 7.2 修改状态的规则 在React中，状态被认为是只读的，我们应该始终替换它而不是修改它，直接修改状态不能引发视图更新\n# 8. 组件的样式处理 React组件基础的样式控制有俩种方式：\n行内样式（不推荐）\nclass类名控制\napp.css\n.foo{ color: red; font-size: 20px; } App.js\n// 导入样式 import \u0026#39;./app.css\u0026#39; const style = { color:\u0026#39;red\u0026#39;, fontSize:\u0026#39;50px\u0026#39; } function App() { return ( \u0026lt;\u0026gt; {/* 行内样式控制 */} \u0026lt;span style={style}\u0026gt;this is line style\u0026lt;/span\u0026gt; {/* 通过class类名控制 */} \u0026lt;span className=\u0026#34;foo\u0026#34;\u0026gt;this is class control style\u0026lt;/span\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 9. 受控表单绑定 概念：使用React组件的状态（useState）控制表单的状态\nApp.js\nimport { useState } from \u0026#34;react\u0026#34;; // 1. 声明一个react状态 - useState // 2. 核心绑定流程 // 2.1 通过value属性绑定react状态 // 2.2 绑定onChange事件，通过事件参数e拿到输入框最新的值，反向修改到react状态 function App() { const [value,setValue] = useState(\u0026#39;\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;input value={value} onChange={(e)=\u0026gt;setValue(e.target.value)}\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 10. React中获取DOM 在 React 组件中获取/操作 DOM，需要使用 useRef React Hook钩子函数，分为两步：\n使用useRef创建 ref 对象，并与 JSX 绑定\n在DOM可用时，通过 inputRef.current 拿到 DOM 对象\nApp.js\nimport {useRef} from \u0026#34;react\u0026#34; // 1. useRef 生成ref对象，绑定到dom标签上 // 2. dom可用时，ref.current获取dom // 渲染完毕之后dom生成之后才可用 function App() { const inputRef = useRef(null) return ( \u0026lt;\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={()=\u0026gt;console.dir(inputRef.current)}\u0026gt;获取dom\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11. 组件通信 概念：组件通信就是组件之间的数据传递，根据组件嵌套关系的不同，有不同的通信方法\n# 11.1 父传子 # 11.1.1 基础实现 实现步骤：\n父组件传递数据 - 在子组件标签上绑定属性\n子组件接收数据 - 子组件通过props参数接收数据\nApp.js\n// 1. 父组件传递数据 - 在子组件标签上绑定属性 // 2. 子组件接收数据 - 子组件通过props参数接收数据 function Son(props){ // props：对象里面包含了父组件传递过来的所有的数据 console.log(props); return \u0026lt;div\u0026gt;this is son,{props.name}\u0026lt;/div\u0026gt; } function App() { const name = \u0026#39;this is app name\u0026#39; return ( \u0026lt;\u0026gt; \u0026lt;Son name={name}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.1.2 父传子-props说明 props可传递任意的数据\n​\t数字、字符串、布尔值、数组、对象、函数、JSX\nprops是只读对象\n​\t子组件只能读取props中的数据，不能直接进行修改, 父组件的数据只能由父组件修改\nfunction Son(props){ console.log(props); return \u0026lt;div\u0026gt;this is son,{props.name},jsx:{props.child}\u0026lt;/div\u0026gt; } function App() { const name = \u0026#39;this is app name\u0026#39; return ( \u0026lt;\u0026gt; \u0026lt;Son name={name} age={18} isTrue={false} list={[\u0026#39;vue\u0026#39;,\u0026#39;react\u0026#39;]} obj={{name:\u0026#39;jack\u0026#39;}} cb={()=\u0026gt;console.log(123)} child={\u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.1.3 父传子-children说明 场景：当我们把内容嵌套在子组件标签中时，父组件会自动在名为children的prop属性中接收该内容\nApp.js\nfunction Son(props){ console.log(props); return \u0026lt;div\u0026gt;this is son,{props.children}\u0026lt;/div\u0026gt; } function App() { return ( \u0026lt;\u0026gt; \u0026lt;Son\u0026gt; \u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt; \u0026lt;/Son\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.2 子传父 App.js\nfunction Son({onGetMsg}){ const sonMsg = \u0026#39;this is son msg\u0026#39; return \u0026lt;div\u0026gt;this is son \u0026lt;button onClick={()=\u0026gt;onGetMsg(sonMsg)}\u0026gt;senMsg\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } function App() { const getMsg = (msg)=\u0026gt;{ console.log(msg); } return ( \u0026lt;\u0026gt; \u0026lt;Son onGetMsg={getMsg}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.3 使用状态提升实现兄弟组件通信 实现思路：借助“状态提升”机制，通过父组件进行兄弟组件之间的数据传递\nA组件先通过子传父的方式把数据传给父组件App\nApp拿到数据后通过父传子的方式再传递给B组件\nApp.js\nimport { useState } from \u0026#34;react\u0026#34; // 1. 通过子传父 A-\u0026gt;App // 2. 通过父传子 App-\u0026gt;B function A({onGetAData}){ // A 组件中数据 const name = \u0026#39;this is A name\u0026#39; return ( \u0026lt;div\u0026gt; this is A component \u0026lt;button onClick={()=\u0026gt;onGetAData(name)}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } function B(props){ // A 组件中数据 return ( \u0026lt;div\u0026gt; this is B component,{props.aMsg} \u0026lt;/div\u0026gt; ) } function App() { const [aMsg,setAMsg] = useState(\u0026#39;\u0026#39;) const getAData=(aData)=\u0026gt;{ console.log(aData); setAMsg(aData) } return ( \u0026lt;\u0026gt; this is App \u0026lt;A onGetAData={getAData}/\u0026gt; \u0026lt;B aMsg={aMsg}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.4 使用Context机制跨层级组件通信 实现步骤：\n使用createContext方法创建一个上下文对象Ctx\n在顶层组件（App）中通过 Ctx.Provider 组件提供数据\n在底层组件（B）中通过 useContext 钩子函数获取消费数据\nApp.js\n// App-\u0026gt;A-\u0026gt;B import { useContext } from \u0026#34;react\u0026#34;; import { createContext } from \u0026#34;react\u0026#34;; // 1. createContext方法创建一个上下文对象 const MsgContext = createContext() function A(){ return ( \u0026lt;div\u0026gt; this is A component \u0026lt;B/\u0026gt; \u0026lt;/div\u0026gt; ) } // 3. 在底层组件，通过useContext钩子函数使用数据 function B(){ const msg = useContext(MsgContext) return ( \u0026lt;div\u0026gt; this is B component,{msg} \u0026lt;/div\u0026gt; ) } function App() { const msg = \u0026#39;this is app msg\u0026#39; return ( \u0026lt;\u0026gt; {/* 2. 在顶层组件，通过Provider组件提供数据 */} \u0026lt;MsgContext.Provider value={msg}\u0026gt; this is App \u0026lt;A/\u0026gt; \u0026lt;/MsgContext.Provider\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12. useEffect的使用 ​\tuseEffect是一个React Hook函数，用于在React组件中创建不是由事件引起而是由渲染本身引起的操作（副作用）, 比\n如发送AJAX请求，更改DOM等等。\n说明：上面的组件中没有发生任何的用户事件，组件渲染完毕之后就需要和服务器要数据，整个过程属于“只由渲染引起的操作”\n# 12.1 useEffect 的基础使用 需求：在组件渲染完毕之后，立刻从服务端获取频道列表数据并显示到页面中\n语法：\nuseEffect(()=\u0026gt;{},[]) 参数1是一个函数，可以把它叫做副作用函数，在函数内部可以放置要执行的操作\n参数2是一个数组（可选参），在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，`当是一个空数组的时候，副作用函数\n只会在组件渲染完毕之后执行一次。`\n接口地址：http://geek.itheima.net/v1_0/channels\nApp.js\nimport { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; const URL = \u0026#34;http://geek.itheima.net/v1_0/channels\u0026#34; function App() { // 创建一个状态数据 const [list,setList] = useState([]) useEffect(()=\u0026gt;{ // 额外的操作，获取频道列表 async function getList(){ const res = await fetch(URL) const jsonResp = await res.json() setList(jsonResp.data.channels) } getList() },[]) return ( \u0026lt;\u0026gt; this is app \u0026lt;ul\u0026gt; {list.map(item=\u0026gt;\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2 useEffect 依赖项参数说明 useEffect副作用函数的执行时机存在多种情况，根据传入依赖项的不同，会有不同的执行表现。\n依赖项 副作用函数执行时机 没有依赖项 组件初始渲染 + 组件更新时执行 空数组依赖项 只在初始渲染时执行一次 添加特定依赖项 组件初始渲染 + 特性依赖项变化时执行 # 12.2.1 没有依赖项 App.js\nimport { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 1. 没有依赖项 组件初始渲染 + 组件更新时执行 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); }) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2.2 空数组依赖项 App.js\nimport { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 2. 空数组依赖项 只在初始渲染时执行一次 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); },[]) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2.3 特定依赖项 App.js\nimport { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 3. 添加特定依赖项 组件初始渲染 + 特性依赖项变化时执行 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); },[count]) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.3 useEffect — 清除副作用 在useEffect中编写的由渲染本身引起的对接组件外部的操作，社区也经常把它叫做副作用操作，比如在useEffect中开\n启了一个定时器，我们想在组件卸载时把这个定时器再清理掉，这个过程就是清理副作用。\nuseEffect(()=\u0026gt;{ // 实现副作用操作逻辑 return ()=\u0026gt;{ //清除副作用逻辑 } },[]) 说明：清除副作用的函数最常见的执行时机是在组件卸载时自动执行\n需求：在Son组件渲染时开启一个定制器，卸载时清除这个定时器\nimport { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function Son(){ // 1. 渲染时开启一个定时器 useEffect(()=\u0026gt;{ const timer = setInterval(()=\u0026gt;{ console.log(\u0026#34;定时器执行中\u0026#34;); },1000) return ()=\u0026gt;{ // 清除副作用（组件卸载时） clearInterval(timer) } },[]) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; } function App() { // 通过条件渲染模拟组件卸载 const [show,setShow] = useState(true) return ( \u0026lt;\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Son/\u0026gt;} \u0026lt;button onClick={()=\u0026gt;setShow(false)}\u0026gt;卸载Son组件\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 13. 自定义Hook函数 概念：自定义Hook是以 use 打头的函数，通过自定义Hook函数可以用来实现逻辑的封装和复用\nimport { useState } from \u0026#34;react\u0026#34;; function useToggle(){ const [value,setValue] = useState(false) const toggle=()=\u0026gt;setValue(!value) return { value, toggle } } // 封装自定义hook通用思路 // 1. 声明一个以use打头的函数； // 2. 在函数体内封装可复用的逻辑（只要是可复用的逻辑）； // 3. 把组件中用到的状态或者回调return出去（以对象或者数组）； // 4. 在哪个组件中要用到这个逻辑，就执行这个函数，解构出来状态和回调进行使用。 function App() { const {value,toggle} = useToggle() return ( \u0026lt;\u0026gt; {value \u0026amp;\u0026amp; \u0026lt;div\u0026gt;this is dive\u0026lt;/div\u0026gt;} \u0026lt;button onClick={toggle}\u0026gt;toggle\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 14. React Hooks使用规则 使用规则\n只能在组件中或者其他自定义Hook函数中调用 只能在组件的顶层调用，不能嵌套在 if、for、其他函数中 # 三、Redux # 1. Redux介绍 Redux 是React最常用的集中状态管理工具，类似于Vue中的Pinia（Vuex），可以独立于框架运行 作用：通过集中管理的方式管理应用的状态\n为什么要使用Redux？\n独立于组件，无视组件之间的层级关系，简化通信问题 单项数据流清晰，易于定位bug 调试工具配套良好，方便调试 # 2. Redux快速体验 # 2.1 实现计数器 需求：不和任何框架绑定，不使用任何构建工具，使用纯Redux实现计数器\n使用步骤：\n定义一个 reducer 函数 （根据当前想要做的修改返回一个新的状态） 使用createStore方法传入 reducer函数 生成一个store实例对象 使用store实例的 subscribe方法 订阅数据的变化（数据一旦变化，可以得到通知） 使用store实例的 dispatch方法提交action对象 触发数据变化（告诉reducer你想怎么改数据） 使用store实例的 getState方法 获取最新的状态数据更新到视图中 代码实现：\n\u0026lt;button id=\u0026#34;decrement\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/redux@latest/dist/redux.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 定义reducer函数 // 作用: 根据不同的action对象，返回不同的新的state // state: 管理的数据初始状态 // action: 对象 type 标记当前想要做什么样的修改 function reducer (state = { count: 0 }, action) { // 数据不可变：基于原始状态生成一个新的状态 if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { count: state.count + 1 } } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { count: state.count - 1 } } return state } // 2. 使用reducer函数生成store实例 const store = Redux.createStore(reducer) // 3. 通过store实例的subscribe订阅数据变化 // 回调函数可以在每次state发生变化的时候自动执行 store.subscribe(() =\u0026gt; { console.log(\u0026#39;state变化了\u0026#39;, store.getState()) document.getElementById(\u0026#39;count\u0026#39;).innerText = store.getState().count }) // 4. 通过store实例的dispatch函数提交action更改状态 const inBtn = document.getElementById(\u0026#39;increment\u0026#39;) inBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 增 store.dispatch({ type: \u0026#39;INCREMENT\u0026#39; }) }) const dBtn = document.getElementById(\u0026#39;decrement\u0026#39;) dBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 减 store.dispatch({ type: \u0026#39;DECREMENT\u0026#39; }) }) // 5. 通过store实例的getState方法获取最新状态更新到视图中 \u0026lt;/script\u0026gt; # 3. Redux数据流架构 Redux的难点是理解它对于数据修改的规则, 下图动态展示了在整个数据的修改中，数据的流向\n为了职责清晰，Redux代码被分为三个核心的概念，我们学redux，其实就是学这三个核心概念之间的配合，三个概念分别是:\nstate: 一个对象 存放着我们管理的数据 action: 一个对象 用来描述你想怎么改数据 reducer: 一个函数 根据action的描述更新state # 4. Redux与React - 环境准备 Redux虽然是一个框架无关可以独立运行的插件，但是社区通常还是把它与React绑定在一起使用，以一个计数器案例体验一下Redux + React 的基础使用\n# 4.1 配套工具 在React中使用redux，官方要求安装俩个其他插件 - Redux Toolkit 和 react-redux\nRedux Toolkit（RTK）- 官方推荐编写Redux逻辑的方式，是一套工具的集合集，简化书写方式\nreact-redux - 用来 链接 Redux 和 React组件 的中间件\n# 4.2 配置基础环境 使用 CRA 快速创建 React 项目 npx create-react-app react-redux 安装配套工具 npm i @reduxjs/toolkit react-redux 启动项目 npm run start # 4.3 store目录结构设计 通常集中状态管理的部分都会单独创建一个单独的 store 目录\n应用通常会有很多个子store模块，所以创建一个 modules 目录，在内部编写业务分类的子store\nstore中的入口文件 index.js 的作用是组合modules中所有的子模块，并导出store\n# 5. Redux与React - 实现counter # 5.1 整体路径熟悉 # 5.2 使用React Toolkit 创建 counterStore modules/counterStore.js\nimport { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; const counterStore = createSlice({ // 模块名称独一无二 name: \u0026#39;counter\u0026#39;, // 初始数据 initialState: { count: 1 }, // 修改数据的同步方法,支持直接修改 reducers: { increment (state) { state.count++ }, decrement(state){ state.count-- } } }) // 解构出actionCreater const { increment,decrement } = counterStore.actions // 获取reducer函数 const counterReducer = counterStore.reducer // 按需导出的方式导出actionCreater export { increment, decrement } // 以默认导出的方式导出reducer export default counterReducer store/index.js\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39; // 导入子模块reducer import counterReducer from \u0026#39;./modules/counterStore\u0026#39; const store = configureStore({ reducer: { // 注册子模块 counter: counterReducer } }) export default store # 5.3 为React注入store react-redux负责把Redux和React 链接 起来，内置 Provider组件 通过 store 参数把创建好的store实例注入到应用中，链接正式建立\nindex.js\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; import App from \u0026#39;./App\u0026#39; // 导入store import store from \u0026#39;./store\u0026#39; // 导入store提供组件Provider import { Provider } from \u0026#39;react-redux\u0026#39; ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render( // 提供store数据 \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; ) # 5.4 React组件使用store中的数据 在React组件中使用store中的数据，需要用到一个钩子函数 - useSelector，它的作用是把store中的数据映射到组件中，使用样例如下：\n# 5.5 React组件修改store中的数据 React组件中修改store中的数据需要借助另外一个hook函数 - useDispatch，它的作用是生成提交action对象的dispatch函数，使用样例如下：\n# 6. Redux与React - 提交action传参 需求：组件中有俩个按钮 add to 10 和 add to 20 可以直接把count值修改到对应的数字，目标count值是在组件中传递过去的，需要在提交action的时候传递参数\n实现方式：在reducers的同步修改方法中添加action对象参数，在调用actionCreater的时候传递参数，参数会被传递到action对象payload属性上\n# 7. Redux与React - 异步action处理 需求理解 实现步骤\n创建store的写法保持不变，配置好同步修改状态的方法 单独封装一个函数，在函数内部return一个新函数，在新函数中 2.1 封装异步请求获取数据 2.2 调用同步actionCreater传入异步数据生成一个action对象，并使用dispatch提交 组件中dispatch的写法保持不变 代码实现\n测试接口地址： http://geek.itheima.net/v1_0/channels\nchannelStore.js\nimport { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import axios from \u0026#39;axios\u0026#39; const channelStore = createSlice({ name: \u0026#39;channel\u0026#39;, initialState: { channelList: [] }, reducers: { setChannelList (state, action) { state.channelList = action.payload } } }) // 创建异步 const { setChannelList } = channelStore.actions const url = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; // 封装一个函数 在函数中return一个新函数 在新函数中封装异步 // 得到数据之后通过dispatch函数 触发修改 const fetchChannelList = () =\u0026gt; { return async (dispatch) =\u0026gt; { const res = await axios.get(url) dispatch(setChannelList(res.data.data.channels)) } } export { fetchChannelList } const channelReducer = channelStore.reducer export default channelReducer store/index.js\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39; // 导入子模块reducer import counterReducer from \u0026#39;./modules/counterStore\u0026#39; import channelReducer from \u0026#39;./modules/channelStore\u0026#39; const store = configureStore({ reducer: { // 注册子模块 counter: counterReducer, channel: channelReducer } }) export default store App.js\nimport { useEffect } from \u0026#39;react\u0026#39; import { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39; import { fetchChannelList } from \u0026#39;./store/channelStore\u0026#39; function App () { // 使用数据 const { channelList } = useSelector(state =\u0026gt; state.channel) useEffect(() =\u0026gt; { dispatch(fetchChannelList()) }, [dispatch]) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {channelList.map(task =\u0026gt; \u0026lt;li key={task.id}\u0026gt;{task.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 8. Redux调试 - devtools Redux官方提供了针对于Redux的调试工具，支持实时state信息展示，action提交信息查看等\n# 四、ReactRouter # 4.1 ReactRouter快速体验 # 4.1.1 什么是前端路由 一个路径 path 对应一个组件 component 当我们在浏览器中访问一个 path 的时候，path 对应的组件会在页面中进行渲染 # 4.1.2 创建路由开发环境 # 使用CRA创建项目 npm create-react-app react-router-pro # 安装最新的ReactRouter包 npm i react-router-dom # 启动项目 npm run start # 4.1.3 快速开始 index.js\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; // 1.创建router实例对象并且配置路由对应关系 const router = createBrowserRouter([ { path:\u0026#39;/login\u0026#39;, element: \u0026lt;div\u0026gt;登录\u0026lt;/div\u0026gt; }, { path:\u0026#39;/article\u0026#39;, element: \u0026lt;div\u0026gt;文章\u0026lt;/div\u0026gt; } ]) ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render( {/* 2.路由绑定 */} \u0026lt;RouterProvider router={router}/\u0026gt; ) # 4.1.4 抽象路由模块 pages/Article/index.js\nconst Article = ()=\u0026gt;{ return \u0026lt;div\u0026gt;我是文章页\u0026lt;/div\u0026gt; } export default Article pages/Login/index.js\nconst Login = ()=\u0026gt;{ return \u0026lt;div\u0026gt;我是登录页\u0026lt;/div\u0026gt; } export default Login router/index.js\nimport Login from \u0026#34;../pages/Login\u0026#34;; import Article from \u0026#34;../pages/Article\u0026#34;; import { createBrowserRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createBrowserRouter([ { path:\u0026#39;/login\u0026#39;, element:\u0026lt;Login/\u0026gt; }, { path:\u0026#39;/article\u0026#39;, element:\u0026lt;Article/\u0026gt; } ]); export default router index.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; import \u0026#39;./index.css\u0026#39;; import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; import { RouterProvider } from \u0026#39;react-router-dom\u0026#39;; import router from \u0026#39;./router\u0026#39;; const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;RouterProvider router={router}\u0026gt;\u0026lt;/RouterProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); # 4.2 路由导航 # 4.2.1 什么是路由导航 路由系统中的多个路由之间需要进行路由跳转，并且在跳转的同时有可能需要传递参数进行通信 # 4.2.2 声明式导航 声明式导航是指通过在模版中通过 \u0026lt;Link/\u0026gt; 组件描述出要跳转到哪里去，比如后台管理系统的左侧菜单通常使用这种方式进行\n语法说明：通过给组件的to属性指定要跳转到路由path，组件会被渲染为浏览器支持的a链接，如果需要传参直接通过字符串拼接的方式拼接参数即可\n# 4.2.3 编程式导航 编程式导航是指通过 useNavigate 钩子得到导航方法，然后通过调用方法以命令式的形式进行路由跳转，比如想在登录请求完毕之后跳转就可以选择这种方式，更加灵活\n语法说明：通过调用navigate方法传入地址path实现跳转\n# 4.2. 导航传参 注：params传参要在router/index.js文件path属性里面添加/article/:id/:name。\n# 4.3 嵌套路由配置 # 4.3.1 什么是嵌套路由 在一级路由中又内嵌了其他路由，这种关系就叫做嵌套路由，嵌套至一级路由内的路由又称作二级路由，例如： # 4.3.2 嵌套路由配置 实现步骤\n1. 使用 `children`属性配置路由嵌套关系 2. 使用 `\u0026lt;Outlet/\u0026gt;` 组件配置二级路由渲染位置 # 4.3.3 默认二级路由 当访问的是一级路由时，默认的二级路由组件可以得到渲染，只需要在二级路由的位置去掉path，设置index属性为true\n注：设置默认路由后，获取参数/?id=100，子组件和父组件都可以接受到参数值\n# 4.3.4 404路由配置 场景：当浏览器输入url的路径在整个路由配置中都找不到对应的 path，为了用户体验，可以使用 404 兜底组件进行渲染\n实现步骤：\n准备一个NotFound组件 在路由表数组的末尾，以*号作为路由path配置路由 # 4.3.5 俩种路由模式 各个主流框架的路由常用的路由模式有俩种，history模式和hash模式, ReactRouter分别由 createBrowerRouter 和 createHashRouter 函数负责创建\n路由模式 url表现 底层原理 是否需要后端支持(nginx转发) history url/login history对象 + pushState事件 需要 hash url/#/login 监听hashChange事件 不需要 # 五、常用Hook函数 # 5.1 useReducer 作用：和useState的作用类似，用来管理相对复杂的状态数据\n# 5.1.1 基础用法 定义一个reducer函数（根据不同的action返回不同的新状态） 在组件中调用useReducer，并传入reducer函数和状态的初始值 事件发生时，通过dispatch函数分派一个action对象（通知reducer要返回哪个新状态并渲染UI） App.js\nimport { useReducer } from \u0026#39;react\u0026#39; // 1. 定义reducer函数，根据不同的action返回不同的新状态 function reducer(state, action) { switch (action.type) { case \u0026#39;INC\u0026#39;: return state + 1 case \u0026#39;DEC\u0026#39;: return state - 1 default: return state } } function App() { // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( \u0026lt;\u0026gt; {/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DEC\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; {state} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;INC\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.1.2 修改state值-分派action传参 做法：分派action时如果想要传递参数，需要在action对象中添加一个payload参数，放置状态参数\nApp.js\n// 定义reducer import { useReducer } from \u0026#39;react\u0026#39; // 1. 根据不同的action返回不同的新状态 function reducer(state, action) { console.log(\u0026#39;reducer执行了\u0026#39;) switch (action.type) { case \u0026#39;INC\u0026#39;: return state + 1 case \u0026#39;DEC\u0026#39;: return state - 1 case \u0026#39;UPDATE\u0026#39;: return state + action.payload default: return state } } function App() { // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( \u0026lt;\u0026gt; {/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DEC\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; {state} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;INC\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;UPDATE\u0026#39;, payload: 100 })}\u0026gt; update to 100 \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.1.3 更新流程 # 5.2 useMemo 作用：它在每次重新渲染的时候能够缓存计算的结果\n# 5.2.1 示例 下面我们的本来的用意是想基于count的变化计算斐波那契数列之和，但是当我们修改num状态的时候，斐波那契求和函数也会被执行，显然是一种浪费\n// useMemo // 作用：在组件渲染时缓存计算的结果 import { useState } from \u0026#39;react\u0026#39; function factorialOf(n) { console.log(\u0026#39;斐波那契函数执行了\u0026#39;) return n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1) } function App() { const [count, setCount] = useState(0) // 计算斐波那契之和 const sumByCount = factorialOf(count) const [num, setNum] = useState(0) return ( \u0026lt;\u0026gt; {sum} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+count:{count}\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNum(num + 1)}\u0026gt;+num:{num}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App 优化：useMemo缓存计算结果，只有count发生变化时才重新进行计算\nimport { useMemo, useState } from \u0026#39;react\u0026#39; function fib (n) { console.log(\u0026#39;计算函数执行了\u0026#39;) if (n \u0026lt; 3) return 1 return fib(n - 2) + fib(n - 1) } function App() { const [count, setCount] = useState(0) // 计算斐波那契之和 // const sum = fib(count) // 通过useMemo缓存计算结果，只有count发生变化时才重新计算 const sum = useMemo(() =\u0026gt; { return fib(count) }, [count]) const [num, setNum] = useState(0) return ( \u0026lt;\u0026gt; {sum} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+count:{count}\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNum(num + 1)}\u0026gt;+num:{num}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3 React.memo 作用：允许组件在props没有改变的情况下跳过重新渲染\n# 5.3.1 组件默认的渲染机制 默认机制：顶层组件发生重新渲染，这个组件树的子级组件都会被重新渲染\n// memo // 作用：允许组件在props没有改变的情况下跳过重新渲染 import { useState } from \u0026#39;react\u0026#39; function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; } function App() { const [, forceUpdate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpdate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3.2 使用React.memo优化 机制：只有props发生变化时才重新渲染 下面的子组件通过 memo 进行包裹之后，返回一个新的组件MemoSon, 只有传给MemoSon的props参数发生变化时才会重新渲染\nimport React, { useState } from \u0026#39;react\u0026#39; const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }) function App() { const [, forceUpdate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpdate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App props变化重新渲染\nimport React, { useState } from \u0026#39;react\u0026#39; const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }) function App() { console.log(\u0026#39;父组件重新渲染了\u0026#39;) const [count, setCount] = useState(0) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon count={count} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3.3 props的比较机制 对于props的比较，进行的是‘浅比较’，底层使用 Object.is 进行比较，针对于对象数据类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心对象中的具体属性\n示例：\nprop是简单类型\nObject.is(3,3)=\u0026gt;true 没有变化\nprop是引用类型（对象/数组）\nObject.is([],[])=\u0026gt;false 有变化，React只关心引用是否变化\n// React.memo props比较机制 // 1. 传递一个简单类型的prop prop变化时组件重新渲染 // 2. 传递一个引用类型的prop 比较的是新值和旧值的引用是否相等 当父组件的函数重新执行时，实际上形成的是新的数组引用 // 3. 保证引用稳定 -》 useMemo 组件渲染过程中缓存一个值 import { useMemo } from \u0026#34;react\u0026#34;; import { useState } from \u0026#34;react\u0026#34;; import { memo } from \u0026#34;react\u0026#34;; const MemoSon= memo(function Son({list}){ console.log(\u0026#39;子组件重新渲染\u0026#39;); return \u0026lt;div\u0026gt;this is Son{list}\u0026lt;/div\u0026gt; }) function App() { const [count,setCount] = useState(0) const list = useMemo(()=\u0026gt;{ return [1,2,3] },[]) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;MemoSon list={list}/\u0026gt; \u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;change count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; # 5.3.4 自定义比较函数 如果上一小节的例子，我们不想通过引用来比较，而是完全比较数组的成员是否完全一致，则可以通过自定义比较函数来实现\nimport React, { useState } from \u0026#39;react\u0026#39; // 自定义比较函数 function arePropsEqual(oldProps, newProps) { console.log(oldProps, newProps) return ( oldProps.list.length === newProps.list.length \u0026amp;\u0026amp; oldProps.list.every((oldItem, index) =\u0026gt; { const newItem = newProps.list[index] console.log(newItem, oldItem) return oldItem === newItem }) ) } const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }, arePropsEqual) function App() { console.log(\u0026#39;父组件重新渲染了\u0026#39;) const [list, setList] = useState([1, 2, 3]) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon list={list} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; setList([1, 2, 3])}\u0026gt; 内容一样{JSON.stringify(list)} \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setList([4, 5, 6])}\u0026gt; 内容不一样{JSON.stringify(list)} \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.4 useCallback 作用：在组件多次重新渲染的时候缓存函数\nuseCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用\n// useCallBack import { memo, useCallback, useState } from \u0026#39;react\u0026#39; const MemoSon = memo(function Son() { console.log(\u0026#39;Son组件渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; }) function App() { const [, forceUpate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) const onGetSonMessage = useCallback((message) =\u0026gt; { console.log(message) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;MemoSon onGetSonMessage={onGetSonMessage} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 5.5 forwardRef 作用：允许组件使用ref将一个DOM节点暴露给父组件\nimport { forwardRef, useRef } from \u0026#39;react\u0026#39; const MyInput = forwardRef(function Input(props, ref) { return \u0026lt;input {...props} type=\u0026#34;text\u0026#34; ref={ref} /\u0026gt; }, []) function App() { const ref = useRef(null) const focusHandle = () =\u0026gt; { console.log(ref.current.focus()) } return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={ref} /\u0026gt; \u0026lt;button onClick={focusHandle}\u0026gt;focus\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 5.6 useImperativeHandle 作用：通过ref暴露子组件中的方法\nimport { forwardRef, useImperativeHandle, useRef } from \u0026#39;react\u0026#39; const MyInput = forwardRef(function Input(props, ref) { // 实现内部的聚焦逻辑 const inputRef = useRef(null) const focus = () =\u0026gt; inputRef.current.focus() // 暴露子组件内部的聚焦方法 useImperativeHandle(ref, () =\u0026gt; { return { focus, } }) return \u0026lt;input {...props} ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; }) function App() { const ref = useRef(null) const focusHandle = () =\u0026gt; ref.current.focus() return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={ref} /\u0026gt; \u0026lt;button onClick={focusHandle}\u0026gt;focus\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 六、 zustand状态管理 # 6.1 快速上手 store/index.js\nimport { create } from \u0026#39;zustand\u0026#39; // 1. 创建store // 语法容易出错 // 1. 函数参数必须返回一个对象，对象内部编写状态数据和方法 // 2. set是用来修改数据的专门方法必须调用它来修改数据 // 语法1：参数是函数 需要在原数据基础上修改 set(state =\u0026gt; ({ count: state.count + 1 })) // 语法2：参数直接是一个对象 替换原数据 set({count:100}) const useStore = create((set) =\u0026gt; { return { count: 0, inc: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } }) export default useStore App.js\nimport useStore from \u0026#39;./store/useCounterStore.js\u0026#39; function App() { const { count, inc } = useStore() return \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; } export default App # 6.2 异步支持 对于异步操作的支持不需要特殊的操作，直接在函数中编写异步逻辑，最后把接口的数据放到set函数中返回即可\nstore/index.js\nimport { create } from \u0026#39;zustand\u0026#39; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; const useStore = create((set) =\u0026gt; { return { count: 0, ins: () =\u0026gt; { return set(state =\u0026gt; ({ count: state.count + 1 })) }, channelList: [], fetchChannelList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({channelList: jsonData.data.channels}) } } }) export default useStore App.js\nimport { useEffect } from \u0026#39;react\u0026#39; import useChannelStore from \u0026#39;./store/channelStore\u0026#39; function App() { const { channelList, fetchChannelList } = useChannelStore() useEffect(() =\u0026gt; { fetchChannelList() }, [fetchChannelList]) return ( \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ) } export default App # 6.3 切片模式 场景：当我们单个store比较大的时候，可以采用一种切片模式进行模块拆分再组合\nstore/index.js\nimport { create } from \u0026#39;zustand\u0026#39; // 创建counter相关切片 const createCounterStore = (set) =\u0026gt; { return { count: 0, setCount: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } } // 创建channel相关切片 const createChannelStore = (set) =\u0026gt; { return { channelList: [], fetchGetList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({ channelList: jsonData.data.channels }) } } } // 组合切片 const useStore = create((...a) =\u0026gt; ({ ...createCounterStore(...a), ...createChannelStore(...a) })) App.js\nfunction App() { const {count, inc, channelList, fetchChannelList } = useStore() return ( \u0026lt;\u0026gt; \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 九、工具类 # 1. lodash 排序工具 # 2. classnames 优化类名控制 # 3. dayjs ","date":"2024-05-06T17:00:00+08:00","image":"https://blog.binggao.xyz/p/react-basic/assets/1_hu98f6fd50a4f2e293a2be77495df51183_325303_120x120_fill_box_smart1_3.png","permalink":"https://blog.binggao.xyz/p/react-basic/","title":"React18 基础"}]