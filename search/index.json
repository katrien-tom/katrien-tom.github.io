[{"content":" # React 18 基础 # 一、React项目结构 # 1. 清理文件 # 二、JSX基础 # 1. 识别js表达式 在JSX中可以通过 大括号语法{} 识别 JavaScript中的表达式，比如常见的变量、函数调用、方法调用等等。\n使用引号传递字符串\n使用JavaScript变量\n函数调用和方法调用\n使用JavaScript对象\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const count = 100; function getName(){ return \u0026#39;react\u0026#39;; } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is react App {/* 使用引号传递字符串 */} {\u0026#39;this is mesages\u0026#39;} {/* 识别js变量 */} {count} {/* 函数调用 */} {getName()} {/* 方法调用 */} {new Date().getDate()} {/* 使用js对象 */} \u0026lt;div style={{color:\u0026#39;red\u0026#39;}}\u0026gt;this is div\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 注意：if语句、switch语句、变量声明属于语句，不是表达式，不能出现在{}中\n# 2. JSX中实现列表渲染 语法：在JSX中可以使用原生JS中的map方法遍历渲染列表\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const list= [ {id:1001,name:\u0026#39;Vue\u0026#39;}, {id:1002,name:\u0026#39;React\u0026#39;}, {id:1003,name:\u0026#39;Angular\u0026#39;}, ] function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 渲染列表 */} {/* map 循环哪个结构 return结构 */} {/* 注意事项：加上一个独一无二的key、字符串或者number */} {/* key的作用：React框架内部使用，提升更新性能的 */} \u0026lt;ul\u0026gt; {list.map(item=\u0026gt;\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; # 3. 条件渲染 语法：在React中，可以通过逻辑与运算符\u0026amp;\u0026amp;、三元表达式（?:）实现基础的条件渲染\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const isLogin = true; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 逻辑与 \u0026amp;\u0026amp; */} {isLogin\u0026amp;\u0026amp;\u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt;} {/* 三元运算 */} {isLogin ? \u0026lt;span\u0026gt;jack\u0026lt;/span\u0026gt;:\u0026lt;span\u0026gt;loading\u0026lt;/span\u0026gt;} \u0026lt;/div\u0026gt; ); } export default App; # 4. 复杂条件渲染 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const articleType = 2; // 0 1 3 //定义核心函数（根据文章类型返回不同的JSX模板 function getArticleTem() { if (articleType === 0) { return \u0026lt;div\u0026gt;我是无图模式\u0026lt;/div\u0026gt;; } else if (articleType === 1) { return \u0026lt;div\u0026gt;我是单图模式\u0026lt;/div\u0026gt;; } else { return \u0026lt;div\u0026gt;我是三图模式\u0026lt;/div\u0026gt;; } } function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 调用函数渲染不同的模板 */} {getArticleTem()} \u0026lt;/div\u0026gt; ); } export default App; # 5. React中的事件绑定 语法：on + 事件名称 = { 事件处理程序 }，整体上遵循驼峰命名法\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function App() { const clickHandler1 = (e)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,e); } const clickHandler2 = (param)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,param); } const clickHandler3 = (param,e)=\u0026gt;{ console.log(\u0026#39;button按钮点击了\u0026#39;,param,e); } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={clickHandler1}\u0026gt;click me1\u0026lt;/button\u0026gt; \u0026lt;button onClick={()=\u0026gt;clickHandler2(\u0026#39;jack\u0026#39;)}\u0026gt;click me2\u0026lt;/button\u0026gt; \u0026lt;button onClick={(e)=\u0026gt;clickHandler3(\u0026#39;jack\u0026#39;,e)}\u0026gt;click me3\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 6. React中的组件 概念：一个组件就是用户界面的一部分，它可以有自己的逻辑和外观，组件之间可以互相嵌套，也可以复用多次\n组件化开发可以让开发者像搭积木一样构建一个完整的庞大的应用。\n# 6.1 React组件 在React中，一个组件就是首字母大写的函数，内部存放了组件的逻辑和视图UI, 渲染组件只需要把组件当成标签书写即可。\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Button(){ // 业务逻辑组件逻辑 return \u0026lt;button\u0026gt;click me!\u0026lt;/button\u0026gt; } function App() { return ( \u0026lt;\u0026gt; {/* 自闭和 */} \u0026lt;Button/\u0026gt; {/* 成对标签 */} \u0026lt;Button\u0026gt;\u0026lt;/Button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 7. useState useState 是一个 React Hook（函数），它允许我们向组件添加一个状态变量, 从而控制影响组件的渲染结果。\n# 7.1 useState基础使用 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { useState } from \u0026#34;react\u0026#34;; function App() { // 1. 调用useState 添加一个状态变量 // count 状态变量 // setCount 修改状态变量的方法 const [count,setCount] = useState(0) // 2. 点击事件回调 const clickHandlerCallback=()=\u0026gt;{ // 作用1. 用传入的新值需改count // 2.重新使用新的count渲染ui setCount(count+1) } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={clickHandlerCallback}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 7.2 修改状态的规则 在React中，状态被认为是只读的，我们应该始终替换它而不是修改它，直接修改状态不能引发视图更新\n# 8. 组件的样式处理 React组件基础的样式控制有俩种方式：\n行内样式（不推荐）\nclass类名控制\napp.css\n1 2 3 4 .foo{ color: red; font-size: 20px; } App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 导入样式 import \u0026#39;./app.css\u0026#39; const style = { color:\u0026#39;red\u0026#39;, fontSize:\u0026#39;50px\u0026#39; } function App() { return ( \u0026lt;\u0026gt; {/* 行内样式控制 */} \u0026lt;span style={style}\u0026gt;this is line style\u0026lt;/span\u0026gt; {/* 通过class类名控制 */} \u0026lt;span className=\u0026#34;foo\u0026#34;\u0026gt;this is class control style\u0026lt;/span\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 9. 受控表单绑定 概念：使用React组件的状态（useState）控制表单的状态\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { useState } from \u0026#34;react\u0026#34;; // 1. 声明一个react状态 - useState // 2. 核心绑定流程 // 2.1 通过value属性绑定react状态 // 2.2 绑定onChange事件，通过事件参数e拿到输入框最新的值，反向修改到react状态 function App() { const [value,setValue] = useState(\u0026#39;\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;input value={value} onChange={(e)=\u0026gt;setValue(e.target.value)}\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 10. React中获取DOM 在 React 组件中获取/操作 DOM，需要使用 useRef React Hook钩子函数，分为两步：\n使用useRef创建 ref 对象，并与 JSX 绑定\n在DOM可用时，通过 inputRef.current 拿到 DOM 对象\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import {useRef} from \u0026#34;react\u0026#34; // 1. useRef 生成ref对象，绑定到dom标签上 // 2. dom可用时，ref.current获取dom // 渲染完毕之后dom生成之后才可用 function App() { const inputRef = useRef(null) return ( \u0026lt;\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={()=\u0026gt;console.dir(inputRef.current)}\u0026gt;获取dom\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11. 组件通信 概念：组件通信就是组件之间的数据传递，根据组件嵌套关系的不同，有不同的通信方法\n# 11.1 父传子 # 11.1.1 基础实现 实现步骤：\n父组件传递数据 - 在子组件标签上绑定属性\n子组件接收数据 - 子组件通过props参数接收数据\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 1. 父组件传递数据 - 在子组件标签上绑定属性 // 2. 子组件接收数据 - 子组件通过props参数接收数据 function Son(props){ // props：对象里面包含了父组件传递过来的所有的数据 console.log(props); return \u0026lt;div\u0026gt;this is son,{props.name}\u0026lt;/div\u0026gt; } function App() { const name = \u0026#39;this is app name\u0026#39; return ( \u0026lt;\u0026gt; \u0026lt;Son name={name}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.1.2 父传子-props说明 props可传递任意的数据\n​\t数字、字符串、布尔值、数组、对象、函数、JSX\nprops是只读对象\n​\t子组件只能读取props中的数据，不能直接进行修改, 父组件的数据只能由父组件修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function Son(props){ console.log(props); return \u0026lt;div\u0026gt;this is son,{props.name},jsx:{props.child}\u0026lt;/div\u0026gt; } function App() { const name = \u0026#39;this is app name\u0026#39; return ( \u0026lt;\u0026gt; \u0026lt;Son name={name} age={18} isTrue={false} list={[\u0026#39;vue\u0026#39;,\u0026#39;react\u0026#39;]} obj={{name:\u0026#39;jack\u0026#39;}} cb={()=\u0026gt;console.log(123)} child={\u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt;} /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.1.3 父传子-children说明 场景：当我们把内容嵌套在子组件标签中时，父组件会自动在名为children的prop属性中接收该内容\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function Son(props){ console.log(props); return \u0026lt;div\u0026gt;this is son,{props.children}\u0026lt;/div\u0026gt; } function App() { return ( \u0026lt;\u0026gt; \u0026lt;Son\u0026gt; \u0026lt;span\u0026gt;this is span\u0026lt;/span\u0026gt; \u0026lt;/Son\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.2 子传父 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function Son({onGetMsg}){ const sonMsg = \u0026#39;this is son msg\u0026#39; return \u0026lt;div\u0026gt;this is son \u0026lt;button onClick={()=\u0026gt;onGetMsg(sonMsg)}\u0026gt;senMsg\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } function App() { const getMsg = (msg)=\u0026gt;{ console.log(msg); } return ( \u0026lt;\u0026gt; \u0026lt;Son onGetMsg={getMsg}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.3 使用状态提升实现兄弟组件通信 实现思路：借助“状态提升”机制，通过父组件进行兄弟组件之间的数据传递\nA组件先通过子传父的方式把数据传给父组件App\nApp拿到数据后通过父传子的方式再传递给B组件\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import { useState } from \u0026#34;react\u0026#34; // 1. 通过子传父 A-\u0026gt;App // 2. 通过父传子 App-\u0026gt;B function A({onGetAData}){ // A 组件中数据 const name = \u0026#39;this is A name\u0026#39; return ( \u0026lt;div\u0026gt; this is A component \u0026lt;button onClick={()=\u0026gt;onGetAData(name)}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } function B(props){ // A 组件中数据 return ( \u0026lt;div\u0026gt; this is B component,{props.aMsg} \u0026lt;/div\u0026gt; ) } function App() { const [aMsg,setAMsg] = useState(\u0026#39;\u0026#39;) const getAData=(aData)=\u0026gt;{ console.log(aData); setAMsg(aData) } return ( \u0026lt;\u0026gt; this is App \u0026lt;A onGetAData={getAData}/\u0026gt; \u0026lt;B aMsg={aMsg}/\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 11.4 使用Context机制跨层级组件通信 实现步骤：\n使用createContext方法创建一个上下文对象Ctx\n在顶层组件（App）中通过 Ctx.Provider 组件提供数据\n在底层组件（B）中通过 useContext 钩子函数获取消费数据\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // App-\u0026gt;A-\u0026gt;B import { useContext } from \u0026#34;react\u0026#34;; import { createContext } from \u0026#34;react\u0026#34;; // 1. createContext方法创建一个上下文对象 const MsgContext = createContext() function A(){ return ( \u0026lt;div\u0026gt; this is A component \u0026lt;B/\u0026gt; \u0026lt;/div\u0026gt; ) } // 3. 在底层组件，通过useContext钩子函数使用数据 function B(){ const msg = useContext(MsgContext) return ( \u0026lt;div\u0026gt; this is B component,{msg} \u0026lt;/div\u0026gt; ) } function App() { const msg = \u0026#39;this is app msg\u0026#39; return ( \u0026lt;\u0026gt; {/* 2. 在顶层组件，通过Provider组件提供数据 */} \u0026lt;MsgContext.Provider value={msg}\u0026gt; this is App \u0026lt;A/\u0026gt; \u0026lt;/MsgContext.Provider\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12. useEffect的使用 ​\tuseEffect是一个React Hook函数，用于在React组件中创建不是由事件引起而是由渲染本身引起的操作（副作用）, 比\n如发送AJAX请求，更改DOM等等。\n说明：上面的组件中没有发生任何的用户事件，组件渲染完毕之后就需要和服务器要数据，整个过程属于“只由渲染引起的操作”\n# 12.1 useEffect 的基础使用 需求：在组件渲染完毕之后，立刻从服务端获取频道列表数据并显示到页面中\n语法：\n1 useEffect(()=\u0026gt;{},[]) 参数1是一个函数，可以把它叫做副作用函数，在函数内部可以放置要执行的操作\n参数2是一个数组（可选参），在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，`当是一个空数组的时候，副作用函数\n只会在组件渲染完毕之后执行一次。`\n接口地址：http://geek.itheima.net/v1_0/channels\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; const URL = \u0026#34;http://geek.itheima.net/v1_0/channels\u0026#34; function App() { // 创建一个状态数据 const [list,setList] = useState([]) useEffect(()=\u0026gt;{ // 额外的操作，获取频道列表 async function getList(){ const res = await fetch(URL) const jsonResp = await res.json() setList(jsonResp.data.channels) } getList() },[]) return ( \u0026lt;\u0026gt; this is app \u0026lt;ul\u0026gt; {list.map(item=\u0026gt;\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2 useEffect 依赖项参数说明 useEffect副作用函数的执行时机存在多种情况，根据传入依赖项的不同，会有不同的执行表现。\n依赖项 副作用函数执行时机 没有依赖项 组件初始渲染 + 组件更新时执行 空数组依赖项 只在初始渲染时执行一次 添加特定依赖项 组件初始渲染 + 特性依赖项变化时执行 # 12.2.1 没有依赖项 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 1. 没有依赖项 组件初始渲染 + 组件更新时执行 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); }) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2.2 空数组依赖项 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 2. 空数组依赖项 只在初始渲染时执行一次 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); },[]) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.2.3 特定依赖项 App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function App() { const [count,setCount] = useState(0) // 3. 添加特定依赖项 组件初始渲染 + 特性依赖项变化时执行 useEffect(()=\u0026gt;{ console.log(\u0026#34;副作用函数执行了\u0026#34;); },[count]) return ( \u0026lt;\u0026gt; this is app \u0026lt;button onClick={()=\u0026gt;setCount(count+1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 12.3 useEffect — 清除副作用 在useEffect中编写的由渲染本身引起的对接组件外部的操作，社区也经常把它叫做副作用操作，比如在useEffect中开\n启了一个定时器，我们想在组件卸载时把这个定时器再清理掉，这个过程就是清理副作用。\n1 2 3 4 5 6 useEffect(()=\u0026gt;{ // 实现副作用操作逻辑 return ()=\u0026gt;{ //清除副作用逻辑 } },[]) 说明：清除副作用的函数最常见的执行时机是在组件卸载时自动执行\n需求：在Son组件渲染时开启一个定制器，卸载时清除这个定时器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; function Son(){ // 1. 渲染时开启一个定时器 useEffect(()=\u0026gt;{ const timer = setInterval(()=\u0026gt;{ console.log(\u0026#34;定时器执行中\u0026#34;); },1000) return ()=\u0026gt;{ // 清除副作用（组件卸载时） clearInterval(timer) } },[]) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; } function App() { // 通过条件渲染模拟组件卸载 const [show,setShow] = useState(true) return ( \u0026lt;\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Son/\u0026gt;} \u0026lt;button onClick={()=\u0026gt;setShow(false)}\u0026gt;卸载Son组件\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 13. 自定义Hook函数 概念：自定义Hook是以 use 打头的函数，通过自定义Hook函数可以用来实现逻辑的封装和复用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { useState } from \u0026#34;react\u0026#34;; function useToggle(){ const [value,setValue] = useState(false) const toggle=()=\u0026gt;setValue(!value) return { value, toggle } } // 封装自定义hook通用思路 // 1. 声明一个以use打头的函数； // 2. 在函数体内封装可复用的逻辑（只要是可复用的逻辑）； // 3. 把组件中用到的状态或者回调return出去（以对象或者数组）； // 4. 在哪个组件中要用到这个逻辑，就执行这个函数，解构出来状态和回调进行使用。 function App() { const {value,toggle} = useToggle() return ( \u0026lt;\u0026gt; {value \u0026amp;\u0026amp; \u0026lt;div\u0026gt;this is dive\u0026lt;/div\u0026gt;} \u0026lt;button onClick={toggle}\u0026gt;toggle\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } export default App; # 14. React Hooks使用规则 使用规则\n只能在组件中或者其他自定义Hook函数中调用 只能在组件的顶层调用，不能嵌套在 if、for、其他函数中 # 三、Redux # 1. Redux介绍 Redux 是React最常用的集中状态管理工具，类似于Vue中的Pinia（Vuex），可以独立于框架运行 作用：通过集中管理的方式管理应用的状态\n为什么要使用Redux？\n独立于组件，无视组件之间的层级关系，简化通信问题 单项数据流清晰，易于定位bug 调试工具配套良好，方便调试 # 2. Redux快速体验 # 2.1 实现计数器 需求：不和任何框架绑定，不使用任何构建工具，使用纯Redux实现计数器\n使用步骤：\n定义一个 reducer 函数 （根据当前想要做的修改返回一个新的状态） 使用createStore方法传入 reducer函数 生成一个store实例对象 使用store实例的 subscribe方法 订阅数据的变化（数据一旦变化，可以得到通知） 使用store实例的 dispatch方法提交action对象 触发数据变化（告诉reducer你想怎么改数据） 使用store实例的 getState方法 获取最新的状态数据更新到视图中 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;button id=\u0026#34;decrement\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/redux@latest/dist/redux.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 1. 定义reducer函数 // 作用: 根据不同的action对象，返回不同的新的state // state: 管理的数据初始状态 // action: 对象 type 标记当前想要做什么样的修改 function reducer (state = { count: 0 }, action) { // 数据不可变：基于原始状态生成一个新的状态 if (action.type === \u0026#39;INCREMENT\u0026#39;) { return { count: state.count + 1 } } if (action.type === \u0026#39;DECREMENT\u0026#39;) { return { count: state.count - 1 } } return state } // 2. 使用reducer函数生成store实例 const store = Redux.createStore(reducer) // 3. 通过store实例的subscribe订阅数据变化 // 回调函数可以在每次state发生变化的时候自动执行 store.subscribe(() =\u0026gt; { console.log(\u0026#39;state变化了\u0026#39;, store.getState()) document.getElementById(\u0026#39;count\u0026#39;).innerText = store.getState().count }) // 4. 通过store实例的dispatch函数提交action更改状态 const inBtn = document.getElementById(\u0026#39;increment\u0026#39;) inBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 增 store.dispatch({ type: \u0026#39;INCREMENT\u0026#39; }) }) const dBtn = document.getElementById(\u0026#39;decrement\u0026#39;) dBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 减 store.dispatch({ type: \u0026#39;DECREMENT\u0026#39; }) }) // 5. 通过store实例的getState方法获取最新状态更新到视图中 \u0026lt;/script\u0026gt; # 3. Redux数据流架构 Redux的难点是理解它对于数据修改的规则, 下图动态展示了在整个数据的修改中，数据的流向\n为了职责清晰，Redux代码被分为三个核心的概念，我们学redux，其实就是学这三个核心概念之间的配合，三个概念分别是:\nstate: 一个对象 存放着我们管理的数据 action: 一个对象 用来描述你想怎么改数据 reducer: 一个函数 根据action的描述更新state # 4. Redux与React - 环境准备 Redux虽然是一个框架无关可以独立运行的插件，但是社区通常还是把它与React绑定在一起使用，以一个计数器案例体验一下Redux + React 的基础使用\n# 4.1 配套工具 在React中使用redux，官方要求安装俩个其他插件 - Redux Toolkit 和 react-redux\nRedux Toolkit（RTK）- 官方推荐编写Redux逻辑的方式，是一套工具的集合集，简化书写方式\nreact-redux - 用来 链接 Redux 和 React组件 的中间件\n# 4.2 配置基础环境 使用 CRA 快速创建 React 项目 1 npx create-react-app react-redux 安装配套工具 1 npm i @reduxjs/toolkit react-redux 启动项目 1 npm run start # 4.3 store目录结构设计 通常集中状态管理的部分都会单独创建一个单独的 store 目录\n应用通常会有很多个子store模块，所以创建一个 modules 目录，在内部编写业务分类的子store\nstore中的入口文件 index.js 的作用是组合modules中所有的子模块，并导出store\n# 5. Redux与React - 实现counter # 5.1 整体路径熟悉 # 5.2 使用React Toolkit 创建 counterStore modules/counterStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; const counterStore = createSlice({ // 模块名称独一无二 name: \u0026#39;counter\u0026#39;, // 初始数据 initialState: { count: 1 }, // 修改数据的同步方法,支持直接修改 reducers: { increment (state) { state.count++ }, decrement(state){ state.count-- } } }) // 解构出actionCreater const { increment,decrement } = counterStore.actions // 获取reducer函数 const counterReducer = counterStore.reducer // 按需导出的方式导出actionCreater export { increment, decrement } // 以默认导出的方式导出reducer export default counterReducer store/index.js\n1 2 3 4 5 6 7 8 9 10 11 import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39; // 导入子模块reducer import counterReducer from \u0026#39;./modules/counterStore\u0026#39; const store = configureStore({ reducer: { // 注册子模块 counter: counterReducer } }) export default store # 5.3 为React注入store react-redux负责把Redux和React 链接 起来，内置 Provider组件 通过 store 参数把创建好的store实例注入到应用中，链接正式建立\nindex.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; import App from \u0026#39;./App\u0026#39; // 导入store import store from \u0026#39;./store\u0026#39; // 导入store提供组件Provider import { Provider } from \u0026#39;react-redux\u0026#39; ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render( // 提供store数据 \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; ) # 5.4 React组件使用store中的数据 在React组件中使用store中的数据，需要用到一个钩子函数 - useSelector，它的作用是把store中的数据映射到组件中，使用样例如下：\n# 5.5 React组件修改store中的数据 React组件中修改store中的数据需要借助另外一个hook函数 - useDispatch，它的作用是生成提交action对象的dispatch函数，使用样例如下：\n# 6. Redux与React - 提交action传参 需求：组件中有俩个按钮 add to 10 和 add to 20 可以直接把count值修改到对应的数字，目标count值是在组件中传递过去的，需要在提交action的时候传递参数\n实现方式：在reducers的同步修改方法中添加action对象参数，在调用actionCreater的时候传递参数，参数会被传递到action对象payload属性上\n# 7. Redux与React - 异步action处理 需求理解 实现步骤\n创建store的写法保持不变，配置好同步修改状态的方法 单独封装一个函数，在函数内部return一个新函数，在新函数中 2.1 封装异步请求获取数据 2.2 调用同步actionCreater传入异步数据生成一个action对象，并使用dispatch提交 组件中dispatch的写法保持不变 代码实现\n测试接口地址： http://geek.itheima.net/v1_0/channels\nchannelStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; import axios from \u0026#39;axios\u0026#39; const channelStore = createSlice({ name: \u0026#39;channel\u0026#39;, initialState: { channelList: [] }, reducers: { setChannelList (state, action) { state.channelList = action.payload } } }) // 创建异步 const { setChannelList } = channelStore.actions const url = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; // 封装一个函数 在函数中return一个新函数 在新函数中封装异步 // 得到数据之后通过dispatch函数 触发修改 const fetchChannelList = () =\u0026gt; { return async (dispatch) =\u0026gt; { const res = await axios.get(url) dispatch(setChannelList(res.data.data.channels)) } } export { fetchChannelList } const channelReducer = channelStore.reducer export default channelReducer store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39; // 导入子模块reducer import counterReducer from \u0026#39;./modules/counterStore\u0026#39; import channelReducer from \u0026#39;./modules/channelStore\u0026#39; const store = configureStore({ reducer: { // 注册子模块 counter: counterReducer, channel: channelReducer } }) export default store App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { useEffect } from \u0026#39;react\u0026#39; import { useSelector, useDispatch } from \u0026#39;react-redux\u0026#39; import { fetchChannelList } from \u0026#39;./store/channelStore\u0026#39; function App () { // 使用数据 const { channelList } = useSelector(state =\u0026gt; state.channel) useEffect(() =\u0026gt; { dispatch(fetchChannelList()) }, [dispatch]) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {channelList.map(task =\u0026gt; \u0026lt;li key={task.id}\u0026gt;{task.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 8. Redux调试 - devtools Redux官方提供了针对于Redux的调试工具，支持实时state信息展示，action提交信息查看等\n# 四、ReactRouter # 4.1 ReactRouter快速体验 # 4.1.1 什么是前端路由 一个路径 path 对应一个组件 component 当我们在浏览器中访问一个 path 的时候，path 对应的组件会在页面中进行渲染 # 4.1.2 创建路由开发环境 1 2 3 4 5 6 7 8 # 使用CRA创建项目 npm create-react-app react-router-pro # 安装最新的ReactRouter包 npm i react-router-dom # 启动项目 npm run start # 4.1.3 快速开始 index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; // 1.创建router实例对象并且配置路由对应关系 const router = createBrowserRouter([ { path:\u0026#39;/login\u0026#39;, element: \u0026lt;div\u0026gt;登录\u0026lt;/div\u0026gt; }, { path:\u0026#39;/article\u0026#39;, element: \u0026lt;div\u0026gt;文章\u0026lt;/div\u0026gt; } ]) ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render( {/* 2.路由绑定 */} \u0026lt;RouterProvider router={router}/\u0026gt; ) # 4.1.4 抽象路由模块 pages/Article/index.js\n1 2 3 4 5 6 7 const Article = ()=\u0026gt;{ return \u0026lt;div\u0026gt;我是文章页\u0026lt;/div\u0026gt; } export default Article pages/Login/index.js\n1 2 3 4 5 6 7 const Login = ()=\u0026gt;{ return \u0026lt;div\u0026gt;我是登录页\u0026lt;/div\u0026gt; } export default Login router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import Login from \u0026#34;../pages/Login\u0026#34;; import Article from \u0026#34;../pages/Article\u0026#34;; import { createBrowserRouter } from \u0026#34;react-router-dom\u0026#34;; const router = createBrowserRouter([ { path:\u0026#39;/login\u0026#39;, element:\u0026lt;Login/\u0026gt; }, { path:\u0026#39;/article\u0026#39;, element:\u0026lt;Article/\u0026gt; } ]); export default router index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; import \u0026#39;./index.css\u0026#39;; import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; import { RouterProvider } from \u0026#39;react-router-dom\u0026#39;; import router from \u0026#39;./router\u0026#39;; const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;RouterProvider router={router}\u0026gt;\u0026lt;/RouterProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); # 4.2 路由导航 # 4.2.1 什么是路由导航 路由系统中的多个路由之间需要进行路由跳转，并且在跳转的同时有可能需要传递参数进行通信 # 4.2.2 声明式导航 声明式导航是指通过在模版中通过 \u0026lt;Link/\u0026gt; 组件描述出要跳转到哪里去，比如后台管理系统的左侧菜单通常使用这种方式进行\n语法说明：通过给组件的to属性指定要跳转到路由path，组件会被渲染为浏览器支持的a链接，如果需要传参直接通过字符串拼接的方式拼接参数即可\n# 4.2.3 编程式导航 编程式导航是指通过 useNavigate 钩子得到导航方法，然后通过调用方法以命令式的形式进行路由跳转，比如想在登录请求完毕之后跳转就可以选择这种方式，更加灵活\n语法说明：通过调用navigate方法传入地址path实现跳转\n# 4.2. 导航传参 注：params传参要在router/index.js文件path属性里面添加/article/:id/:name。\n# 4.3 嵌套路由配置 # 4.3.1 什么是嵌套路由 在一级路由中又内嵌了其他路由，这种关系就叫做嵌套路由，嵌套至一级路由内的路由又称作二级路由，例如： # 4.3.2 嵌套路由配置 实现步骤\n1. 使用 `children`属性配置路由嵌套关系 2. 使用 `\u0026lt;Outlet/\u0026gt;` 组件配置二级路由渲染位置 # 4.3.3 默认二级路由 当访问的是一级路由时，默认的二级路由组件可以得到渲染，只需要在二级路由的位置去掉path，设置index属性为true\n注：设置默认路由后，获取参数/?id=100，子组件和父组件都可以接受到参数值\n# 4.3.4 404路由配置 场景：当浏览器输入url的路径在整个路由配置中都找不到对应的 path，为了用户体验，可以使用 404 兜底组件进行渲染\n实现步骤：\n准备一个NotFound组件 在路由表数组的末尾，以*号作为路由path配置路由 # 4.3.5 俩种路由模式 各个主流框架的路由常用的路由模式有俩种，history模式和hash模式, ReactRouter分别由 createBrowerRouter 和 createHashRouter 函数负责创建\n路由模式 url表现 底层原理 是否需要后端支持(nginx转发) history url/login history对象 + pushState事件 需要 hash url/#/login 监听hashChange事件 不需要 # 五、常用Hook函数 # 5.1 useReducer 作用：和useState的作用类似，用来管理相对复杂的状态数据\n# 5.1.1 基础用法 定义一个reducer函数（根据不同的action返回不同的新状态） 在组件中调用useReducer，并传入reducer函数和状态的初始值 事件发生时，通过dispatch函数分派一个action对象（通知reducer要返回哪个新状态并渲染UI） App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { useReducer } from \u0026#39;react\u0026#39; // 1. 定义reducer函数，根据不同的action返回不同的新状态 function reducer(state, action) { switch (action.type) { case \u0026#39;INC\u0026#39;: return state + 1 case \u0026#39;DEC\u0026#39;: return state - 1 default: return state } } function App() { // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( \u0026lt;\u0026gt; {/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DEC\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; {state} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;INC\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.1.2 修改state值-分派action传参 做法：分派action时如果想要传递参数，需要在action对象中添加一个payload参数，放置状态参数\nApp.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 定义reducer import { useReducer } from \u0026#39;react\u0026#39; // 1. 根据不同的action返回不同的新状态 function reducer(state, action) { console.log(\u0026#39;reducer执行了\u0026#39;) switch (action.type) { case \u0026#39;INC\u0026#39;: return state + 1 case \u0026#39;DEC\u0026#39;: return state - 1 case \u0026#39;UPDATE\u0026#39;: return state + action.payload default: return state } } function App() { // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( \u0026lt;\u0026gt; {/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DEC\u0026#39; })}\u0026gt;-\u0026lt;/button\u0026gt; {state} \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;INC\u0026#39; })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;UPDATE\u0026#39;, payload: 100 })}\u0026gt; update to 100 \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.1.3 更新流程 # 5.2 useMemo 作用：它在每次重新渲染的时候能够缓存计算的结果\n# 5.2.1 示例 下面我们的本来的用意是想基于count的变化计算斐波那契数列之和，但是当我们修改num状态的时候，斐波那契求和函数也会被执行，显然是一种浪费\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // useMemo // 作用：在组件渲染时缓存计算的结果 import { useState } from \u0026#39;react\u0026#39; function factorialOf(n) { console.log(\u0026#39;斐波那契函数执行了\u0026#39;) return n \u0026lt;= 0 ? 1 : n * factorialOf(n - 1) } function App() { const [count, setCount] = useState(0) // 计算斐波那契之和 const sumByCount = factorialOf(count) const [num, setNum] = useState(0) return ( \u0026lt;\u0026gt; {sum} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+count:{count}\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNum(num + 1)}\u0026gt;+num:{num}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App 优化：useMemo缓存计算结果，只有count发生变化时才重新进行计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { useMemo, useState } from \u0026#39;react\u0026#39; function fib (n) { console.log(\u0026#39;计算函数执行了\u0026#39;) if (n \u0026lt; 3) return 1 return fib(n - 2) + fib(n - 1) } function App() { const [count, setCount] = useState(0) // 计算斐波那契之和 // const sum = fib(count) // 通过useMemo缓存计算结果，只有count发生变化时才重新计算 const sum = useMemo(() =\u0026gt; { return fib(count) }, [count]) const [num, setNum] = useState(0) return ( \u0026lt;\u0026gt; {sum} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+count:{count}\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNum(num + 1)}\u0026gt;+num:{num}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3 React.memo 作用：允许组件在props没有改变的情况下跳过重新渲染\n# 5.3.1 组件默认的渲染机制 默认机制：顶层组件发生重新渲染，这个组件树的子级组件都会被重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // memo // 作用：允许组件在props没有改变的情况下跳过重新渲染 import { useState } from \u0026#39;react\u0026#39; function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; } function App() { const [, forceUpdate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpdate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3.2 使用React.memo优化 机制：只有props发生变化时才重新渲染 下面的子组件通过 memo 进行包裹之后，返回一个新的组件MemoSon, 只有传给MemoSon的props参数发生变化时才会重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React, { useState } from \u0026#39;react\u0026#39; const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }) function App() { const [, forceUpdate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpdate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App props变化重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import React, { useState } from \u0026#39;react\u0026#39; const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }) function App() { console.log(\u0026#39;父组件重新渲染了\u0026#39;) const [count, setCount] = useState(0) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon count={count} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+{count}\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.3.3 props的比较机制 对于props的比较，进行的是‘浅比较’，底层使用 Object.is 进行比较，针对于对象数据类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心对象中的具体属性\n示例：\nprop是简单类型\nObject.is(3,3)=\u0026gt;true 没有变化\nprop是引用类型（对象/数组）\nObject.is([],[])=\u0026gt;false 有变化，React只关心引用是否变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // React.memo props比较机制 // 1. 传递一个简单类型的prop prop变化时组件重新渲染 // 2. 传递一个引用类型的prop 比较的是新值和旧值的引用是否相等 当父组件的函数重新执行时，实际上形成的是新的数组引用 // 3. 保证引用稳定 -》 useMemo 组件渲染过程中缓存一个值 import { useMemo } from \u0026#34;react\u0026#34;; import { useState } from \u0026#34;react\u0026#34;; import { memo } from \u0026#34;react\u0026#34;; const MemoSon= memo(function Son({list}){ console.log(\u0026#39;子组件重新渲染\u0026#39;); return \u0026lt;div\u0026gt;this is Son{list}\u0026lt;/div\u0026gt; }) function App() { const [count,setCount] = useState(0) const list = useMemo(()=\u0026gt;{ return [1,2,3] },[]) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;MemoSon list={list}/\u0026gt; \u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;change count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; # 5.3.4 自定义比较函数 如果上一小节的例子，我们不想通过引用来比较，而是完全比较数组的成员是否完全一致，则可以通过自定义比较函数来实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import React, { useState } from \u0026#39;react\u0026#39; // 自定义比较函数 function arePropsEqual(oldProps, newProps) { console.log(oldProps, newProps) return ( oldProps.list.length === newProps.list.length \u0026amp;\u0026amp; oldProps.list.every((oldItem, index) =\u0026gt; { const newItem = newProps.list[index] console.log(newItem, oldItem) return oldItem === newItem }) ) } const MemoSon = React.memo(function Son() { console.log(\u0026#39;子组件被重新渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is span\u0026lt;/div\u0026gt; }, arePropsEqual) function App() { console.log(\u0026#39;父组件重新渲染了\u0026#39;) const [list, setList] = useState([1, 2, 3]) return ( \u0026lt;\u0026gt; \u0026lt;MemoSon list={list} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; setList([1, 2, 3])}\u0026gt; 内容一样{JSON.stringify(list)} \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setList([4, 5, 6])}\u0026gt; 内容不一样{JSON.stringify(list)} \u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 5.4 useCallback 作用：在组件多次重新渲染的时候缓存函数\nuseCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // useCallBack import { memo, useCallback, useState } from \u0026#39;react\u0026#39; const MemoSon = memo(function Son() { console.log(\u0026#39;Son组件渲染了\u0026#39;) return \u0026lt;div\u0026gt;this is son\u0026lt;/div\u0026gt; }) function App() { const [, forceUpate] = useState() console.log(\u0026#39;父组件重新渲染了\u0026#39;) const onGetSonMessage = useCallback((message) =\u0026gt; { console.log(message) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;MemoSon onGetSonMessage={onGetSonMessage} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; forceUpate(Math.random())}\u0026gt;update\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 5.5 forwardRef 作用：允许组件使用ref将一个DOM节点暴露给父组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { forwardRef, useRef } from \u0026#39;react\u0026#39; const MyInput = forwardRef(function Input(props, ref) { return \u0026lt;input {...props} type=\u0026#34;text\u0026#34; ref={ref} /\u0026gt; }, []) function App() { const ref = useRef(null) const focusHandle = () =\u0026gt; { console.log(ref.current.focus()) } return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={ref} /\u0026gt; \u0026lt;button onClick={focusHandle}\u0026gt;focus\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 5.6 useImperativeHandle 作用：通过ref暴露子组件中的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { forwardRef, useImperativeHandle, useRef } from \u0026#39;react\u0026#39; const MyInput = forwardRef(function Input(props, ref) { // 实现内部的聚焦逻辑 const inputRef = useRef(null) const focus = () =\u0026gt; inputRef.current.focus() // 暴露子组件内部的聚焦方法 useImperativeHandle(ref, () =\u0026gt; { return { focus, } }) return \u0026lt;input {...props} ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; }) function App() { const ref = useRef(null) const focusHandle = () =\u0026gt; ref.current.focus() return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={ref} /\u0026gt; \u0026lt;button onClick={focusHandle}\u0026gt;focus\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App # 六、 zustand状态管理 # 6.1 快速上手 store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { create } from \u0026#39;zustand\u0026#39; // 1. 创建store // 语法容易出错 // 1. 函数参数必须返回一个对象，对象内部编写状态数据和方法 // 2. set是用来修改数据的专门方法必须调用它来修改数据 // 语法1：参数是函数 需要在原数据基础上修改 set(state =\u0026gt; ({ count: state.count + 1 })) // 语法2：参数直接是一个对象 替换原数据 set({count:100}) const useStore = create((set) =\u0026gt; { return { count: 0, inc: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } }) export default useStore App.js\n1 2 3 4 5 6 7 8 import useStore from \u0026#39;./store/useCounterStore.js\u0026#39; function App() { const { count, inc } = useStore() return \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; } export default App # 6.2 异步支持 对于异步操作的支持不需要特殊的操作，直接在函数中编写异步逻辑，最后把接口的数据放到set函数中返回即可\nstore/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { create } from \u0026#39;zustand\u0026#39; const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; const useStore = create((set) =\u0026gt; { return { count: 0, ins: () =\u0026gt; { return set(state =\u0026gt; ({ count: state.count + 1 })) }, channelList: [], fetchChannelList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({channelList: jsonData.data.channels}) } } }) export default useStore App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { useEffect } from \u0026#39;react\u0026#39; import useChannelStore from \u0026#39;./store/channelStore\u0026#39; function App() { const { channelList, fetchChannelList } = useChannelStore() useEffect(() =\u0026gt; { fetchChannelList() }, [fetchChannelList]) return ( \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ) } export default App # 6.3 切片模式 场景：当我们单个store比较大的时候，可以采用一种切片模式进行模块拆分再组合\nstore/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { create } from \u0026#39;zustand\u0026#39; // 创建counter相关切片 const createCounterStore = (set) =\u0026gt; { return { count: 0, setCount: () =\u0026gt; { set(state =\u0026gt; ({ count: state.count + 1 })) } } } // 创建channel相关切片 const createChannelStore = (set) =\u0026gt; { return { channelList: [], fetchGetList: async () =\u0026gt; { const res = await fetch(URL) const jsonData = await res.json() set({ channelList: jsonData.data.channels }) } } } // 组合切片 const useStore = create((...a) =\u0026gt; ({ ...createCounterStore(...a), ...createChannelStore(...a) })) App.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function App() { const {count, inc, channelList, fetchChannelList } = useStore() return ( \u0026lt;\u0026gt; \u0026lt;button onClick={inc}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {channelList.map((item) =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; ) } export default App # 九、工具类 # 1. lodash 排序工具 # 2. classnames 优化类名控制 # 3. dayjs ","date":"2024-05-08T17:00:00+08:00","image":"https://blog.binggao.xyz/p/react/assets/1_hu98f6fd50a4f2e293a2be77495df51183_325303_120x120_fill_box_smart1_3.png","permalink":"https://blog.binggao.xyz/p/react/","title":"React18 基础"}]